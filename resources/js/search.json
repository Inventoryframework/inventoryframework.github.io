[[{"l":"Inventory Framework Plugin"},{"i":"last-update-19th-may-2024","l":"Last update: 19th May, 2024"},{"i":"latest-version-281","l":"Latest version: 2.8.1","p":["Links can be found at the top of the page. Introduction Video"]},{"i":"what-is-the-inventory-framework-plugin","l":"What is the Inventory Framework Plugin?","p":["Nearly every inventory system shares the same foundation, a container with tiles and items slot into those tiles. This Inventory Framework Plugin (IFP) attempts to be that foundation for your project, while allowing for a high level of inventory design, item customization, rapid prototyping and system integration.","From my research, inventory systems were taking 2-6 months or more (depending on how advanced it was) to be designed, bug tested, network tested and to be documented. With this framework, I try to provide you the framework needed to create your perfect inventory system and bring that initial creation time down.","What this provides is the C++ foundation for your programmers and a good Blueprint foundation for your designers, which includes:","Actor component and item parents that handle all the logic for you and are abstract enough so you can implement your mechanics and systems into it.","Widgets that are designer friendly (Easy to implement new logic, add animations to events, create children, etc). They also handle all the drag, drop, highlighting, splitting, combining logic and more.","Advanced data assets for your items instead of data tables.","A system that has no reliance on widgets to create or handle its data, meaning everything you need to know about an item is always accessible.","Container system that allows for infinite items inside of items. This means you can make a backpack, which has several containers, then a gun inside one of those containers and then that gun can have containers which have items inside of them. It can keep going for as long as you want.","Actor appearance duplication system that copies the appearance of your items allowing you to both inspect items and auto-generate icons. It works with all actors, not just item actors. No longer do you need to follow a hierarchy setup like many other inventory systems need. You can create your items however you want and the system will automatically duplicate the appearance for either generating item icons or letting you examine an item.","Powerful in-game and in-editor tools to improve quality control and speed up workflow.","It is NOT an inventory to fully replicate the mechanics of any specific game. If you want your system to behave like a specific game, you will have to implement those specific mechanics yourself. This system does try to provide you with the functions and data to replicate most inventory systems.","If you have any issues or questions neither the videos or documentation answer then feel free to message me on Discord (Variandaemon) or join the discord channel. You can look at the FAQ for more info."]},{"i":"color-sheet","l":"Color Sheet:","p":["functions- variable- category- class"]}],[{"l":"Introduction","p":["This plugin was created for an open-world game that has very strict performance requirements. Because of this, some logic is handled in C++ as an inventory system like this does a lot of math. The design architecture is also designed to give programmers more control of when widgets and data is initialized. The architecture has also been made in mind for large-scale projects. This does mean though that there is a specific and strict workflow for setting up the component for items, especially sub containers. I've made an Editor Utility Widget called InventoryHelper which should prevent most human errors and allow people to work in the system without those strict requirements slowing down your creation process.","The architecture was made with designers in mind, so certain C++ functions can be overridden in Blueprints and some functions are only needed on the Blueprint level. This system is not meant to be purely C++ or Blueprints, rather a healthy mix of the two. If you can't write in C++ or don't have access to anyone who can write C++ code for you, the current functions should allow for you to create nearly any Blueprint logic you should need.","Data Assets are being used instead of Data Tables for a few reasons:","You can create children of the item data asset to create a brand new type of item with its own unique settings and not have those settings clutter the items that aren't relevant to those settings.","You can control their loading and unloading in the Asset Manager.","Easier to create Utility Widgets and automating tests.","It's easier to find out what assets are referencing which data asset, while with Data Tables, it can get messy to find out what asset is referencing a specific row.","Data tables are not ideal for managing massive databases. Anyone who has had to deal with source-control while working on an item will know the pains data tables can bring for a system like this.","For more advanced users, it’s possible to add slate widgets into the data asset editor window. For example, a recoil pattern editor for gun items.","The only con regarding data assets is you don’t get a nice table view like you get with data tables. But you can use the matrix editor which gives you a similar editor to the data tables and is in some ways even more powerful.","The plugin was designed to be installed locally to your project, not the engine. With how the marketplace works and how the engine works, it was much simpler to make this asset a plugin. This has also had the nice side effect of updating the system to be much easier.","Many things have been designed to be as abstract as possible and assume as little as possible about YOUR project and creation process. I do not want to dictate any creative vision and I do not want to step on any toes. I’ve tried to keep the system as painless as possible for you to integrate YOUR systems and assets with this inventory system, such as an attribute, ability or crafting system."]}],[{"l":"Installing the plugin","p":["Video walkthrough of the first steps: https://www.youtube.com/watch?v=78vurTeroX4","Because of how integral an inventory system is to a game, I highly recommend you DO NOT install the plugin to the engine and then use it that way, but instead install the plugin locally to your project. That way you can use the plugin in multiple projects without having a change that works in one project mess up the other project. This means you can also have much better control how the parents behave and work and not have to worry about changes made for another project. But it does mean updating the system is a bit more work, but it is very straight forward if you have source-control set up, as it'll tell you all the changes and you can reimplement any custom changes you made to suit your project. This is not mandatory, but can greatly help in the future when you want to update safely.","Once you are done installing the plugin (either locally or through the engine), I HIGHLY advise you make children of any class in this system once you want to modify the class. This should make updating in the future a lot easier and gives you a lot more customizability.","This does NOT cover how to install an IDE such as Rider or Visual Studio. You should already have an IDE installed. Unreal's docs for setting up Visual Studio There are also a few demo files that you’ll want to replace and enum entries you need to rename to fit your project.","Download the plugin through the Epic games client just like how you would download any other plugin.","If your project doesn’t have any C++ code, you will want to go into the engine and at the top go to Tools -> New C++ Class. It doesn’t matter what you create here or where you save it. This is just to get the engine to generate all the files you need to compile the plugin.","Go to your Unreal Engine installation -> Engine -> Plugins -> Marketplace and copy the InventoryFrameworkPlugin folder.","Go into your project's root folder (Where your .uproject is), create a folder called “Plugins” if you don’t have one.","Paste the InventoryFrameworkPlugin folder into the plugin folder.","Go back to your .uproject, right click and press \"Generate Visual Studio Project Files”.","Open the solution file with whatever IDE you use (For example Visual Studio or Rider) and build the project.","(Optional) You can now uninstall the plugin from the engine through the Epic Games Launcher, though you won't get notifications from the Epic Games client whenever an update is available (The discord announces every update as well).","The engine automatically enables the plugin the majority of the time. In rare cases, it might not enable it. If it didn't, open your project, go to Edit -> Plugins and search for \"Inventory Framework Plugin\" and make sure it's enabled.","Everything in the demo folder is designed to be replaced by your assets/Blueprints. It is only there so you don’t get any errors on startup."]},{"l":"Finding the plugin content in your content browser","p":["To find the blueprints, you will want to start the engine, go into your content browser and make sure that in your settings (1) and make sure \"Show Plugin Content\" (2) is checked. Once that is checked, you will find a \"Plugins\" folder and in there you will find \"InventoryFrameworkPlugin content\" (3)","If you decide to NOT install the plugin locally, you will also have to check \"Show Engine Content\" and then go into Engine -> Plugins -> InventoryFrameworkPlugin Content","It is highly recommended to head over to the How does the system work? page and giving a read before proceeding."]}],[{"l":"Asset Manager","p":["For the asset manager to pick up your item data base and for several tools to function correctly, you must set up the asset manager per project.","Go into Projects Settings.","Under the \"Game\" category, select \"Asset Manager\".","Add a new index and set \"Primary Asset Type\" to \"Items\", set the asset base class to DA_CoreItem, then go into Directories and add all locations where you might store your items (This also searches sub folders).","(Optional) If you are using the crafting system, you will also want to add another index and set \"Primary Asset Type\" to \"CraftingRecipes\", set the asset base class to DA_CoreCraftingRecipe, then go into Directories and add all locations where you might store your recipe's."]},{"l":"Adding custom asset types","p":["Inside your item data assets, you can see in the Developer Settings there's a \" Asset Registry Category\" variable. The default is \"Items\", just like the asset type we just set up in the asset manager.","You are able to either change the default for children of DA_CoreItem to be something unique, or change it per-item. If you have massive item data bases (500+ items), it is recommended to organize your data base using custom asset types.","Whatever you fill in inside of Asset Registry Category, you will need to follow the above steps, but replacing the Primary Asset Type with whatever you put into Asset Registry Category. You also must save the data asset manually after the change."]},{"l":"Validating","p":["To validate your items are being discovered correctly, I suggest going into the InventoryHelper and hitting Refresh near the bottom right. You can also search for your item.","If an item is not appearing there, either the above steps were not followed correctly or the asset manager is ignoring it for some reason. If you go into \"Windows\" and open the output log and find any \"Ignoring PrimaryAssetType Items - Conflicts with SOMECLASSNAME - Asset: ITEMNAMEHERE\" in your message log, it means no data has been changed inside of your data asset or it is identical to another data asset."]},{"l":"Limitations","p":["As of 5.1, there is still no way of mixing normal and blueprint data assets, for now you can only have normal data assets, and you can't do a lot of hierarchy setups. All of your parent files must live at a C++ level. Because the item data asset variable inside FS_InventoryItem lives in C++, there is no way to reference blueprint data assets. If you check \"Has Blueprint Classes\" the system will not work."]},{"l":"Bulk Editing","p":["You'll sometimes find yourself with tons of items and need to modify a large amount of items. This is where a good folder hierarchy setup is essential. In the demo project, every item is in its own folder, but all of those folders are inside DemoShowcase -> Items, if you go into the Items folder, find the filter on the left of the search bar and go into Miscellaneous -> Data Asset you will see every item inside the demo. If you select multiple, then right click and go into Asset Actions -> Bulk Edit Via Property Matrix, you'll find the property matrix editor.","Unreal's docs for the Property Matrix"]}],[{"l":"Adding the component and containers","p":["There are two components, one is the C++ parent and the other is the blueprint child of the C++ component. There is nothing stopping you from making your own BP component with the C++ component as its parent but I still recommend using the Blueprint component. You can also make a blueprint child of the blueprint component, which is the recommended path if you are going to override any functions. You want to add your component to your actor, if you're making an item, I suggest using BP_ItemActor as its parent and the component will automatically get added. Do note though that the item Data Asset only accepts children of BP_ItemActor. Go here if you want to change this behavior","Inside the component you'll find an array called ContainerSettings. These are your settings and where you'll add any items to the container. It is most common to give them a unique name, which you'll later use in the next step to assign them to a container widget. You will also need to set what kind of type this container is inside InventoryType and give the component a widget inside WidgetClass which it'll use to display its containers. Typically for player characters, this is the inventory screen. The order of these containers are important. There are many functions that try and find the first available container, which scans the containers from index 0 to the last index.","Now you'll need to bind your containers to a widget to represent the container. This is optional, there are cases where you might not want a container to have a widget representation. Though the player will not have a widget to interact with the container through. Go into your widget and add a child of WBP_Container to your layout. The plugin comes with a widget called WBP_DemoContainer which has all the visuals set up for you. Then go into your graph and implement the I_InventoryWidgets interface. Find the GetContainers interface function and make an array and add your containers. Somewhere throughout your logic you will need to call BindContainerWithWidget, you can see an example on how I call this function inside BP_Interactable or BP_PlayerCharacter.","The actor must implement the I_Inventory interface and override the GetInventoryComponent function and pass in a reference to the inventory component."]}],[{"l":"Activating the component"},{"l":"Starting the component","p":["Starting the component is very simple, just call AC_Inventory-> StartComponent. The bigger challenge will be deciding when you want to call this function. Typically this can be called at BeginPlay or when the player gets close to the actor. This will depend on some factors, the biggest being if any item inside the component will be visually present AND if they have a spawn chance. For example; a gun with a sight on it and the sight has a spawn chance. The sight's spawn chance might fail, and you might want the sight to get removed off the gun. Another example would be an NPC that is wearing some armor that has a spawn chance. If the armor fails its spawn chance, you'll probably want to modify some attributes and remove the armor.","This type of logic is very project dependant and depends on if the inventory component is eating up any impactful performance. I suggest leaving the StartComponent function on BeginPlay, and when it's time to optimize your games performance, then you start evaluating if calling StartComponent is more worthwhile being called at different times.","The order of the items inside every container is very important. If you hover over an items TileIndex you'll see your options. If an item is set to finding the first tile available or a random tile, then another item attempts to spawn on top of that item, it'll fail. There is a delegate which will fire whenever an item fails to spawn."]},{"l":"Stopping the component","p":["This function will remove all widgets and object references. Under no circumstances should this function be called while the player is actively interacting with the component. Here's a list of scenarios where you want to refrain from calling StopComponent.","The player will be interacting with the component within a short period of time, perhaps within 10 minutes.","If the player will be interacting with the component again, if the component has a lot of items or a lot of containers and it causes a noticable hitch when starting the component, it might be more efficient to keep the component active.","The component has items that have a spawn chance. Every time the component starts, it'll roll these spawn chances.","In a multiplayer scenario, you'll be eating a potentially large RPC call every time you start the component. If you stop the component and the player interacts with this component again, the StartComponent function will call a RPC that might be quite large.","The component can not be stopped while its Listeners array is not empty, which is used for multiplayer.","If your games memory usage is tight, it might be worthwhile trying to call StopComponent, but the above points must be kept in mind.","What might be worthwhile for you to optimize would be to try and clean up any widgets and object references the component is holding onto. That is most often the root of any performance issues after activating a component with a lot of items."]}],[{"l":"Equipping and unequipping items","p":["This documentation covers the default equipment system. In some cases, you might want to implement your own or use a hybrid solution, which is covered more at the bottom of the page.","Deep dive video","A big problem I try to solve with this system is that I did not want to assume anything about how your actors' meshes are set up, how your equipment setup looked like and I did not want to make a base player or actor blueprint. There are two main reasons behind this decision: First is this allows you complete control over what items are attached to (for example if you have a horse and want to give it armor, but the component is only setup on the player) and secondly is that people might already have a player blueprint hierarchy setup and I did not want to mess with that and some people might not want to use my hierarchy setup.","The logic that runs the equipping and unequipping logic is stored in a object and item driver called IO_Equipment and ID_Equipment(if you are unfamiliar with the item driver system, I suggest getting familiar with it first) and they use a struct called EquipmentData, this struct attempts to solve most issues when it comes to having multiple skeletons, meshes or complex equipment logic, such as having a gun attached to a backpack which is attached to the player character and that gun has a sight attached to it or FPS shooter setups where you have a local arms skeleton and then a full body skeleton. This struct also attempts to keep the system away from hard coding any types of “main weapon” and “secondary weapon” or anything of the sort. I’ve found those types of setups often become cumbersome when a designer wants to add or remove these types of things.","Keeping the equipping system inside of a item driver provides a modular way for you to allow any item you want to be equippable, or trigger special animations when its added to an items container. It also allows you to easily implement your own system if you want without rewriting C++ code or affecting how the inventory system works at a fundamental level.","During my research, I found an astonishing amount of different workflows and processes. It was very daunting to try and solve all of them in one go, and maybe my system isn’t perfect, but it tries to solve as many as possible at once, while still being flexible and adjustable.","I recommend reading the comments in the EquipmentData struct (Found in IFP_CoreData.h) and going through ID_Equipment(which is an item driver found in the plugins folder Core -> ActorParents -> DriversAndObjects -> Equipment.) and look at the logic in there to get a better understanding of how the system is using this struct. I would explain it here, but it’s so long and extensive that explaining it in just text and pictures would take too long. This driver attempts to copy the system that is used in GAS with its PlayMontageAndWait function, which creates an object that handles the animation, but I wanted to keep mine inside of Blueprints."]},{"l":"Optimizations","p":["For weapons and equippables, I've implemented three methods of creating your equipment mesh (Item reperesentation):","Blueprint, this allows you to simply use any blueprint you've made as the item representation.","Skeletal mesh","Static mesh","Blueprint's are about 11 times more expensive to spawn than meshes, but are the most customizable. I recommend staying away from using Blueprint's as your item representation whenever possible. For multiplayer, meshes are encouraged even more as they are very cheap to replicate.","For skeletal and static meshes, you gain access to most settings you would have in the details panel while editing them in a blueprint","These optimizations of course only matter depending on the scope of your game. This more or less serves as an idea of what to focus on during the optimization phase of your game and what you might have to look for."]},{"l":"Profiler","p":["Blueprints took 1.5ms, while static mesh only took 0.131ms"]},{"l":"Notes regarding Skeletal and Static Meshes","p":["The default material section is not available (I assume this is an engine bug?). If you wish to change the default materials, go into Rendering -> Override Materials"]},{"l":"Notes for optimal multiplayer experience","p":["The way Unreal handles replication for attached actors is not the most elegant. When another player becomes relevant for another client, not all attached actors will get replicated within the same frame, and they might not even replicate in the order that you want them to. Leading to odd snapping or pop-in. This could be awkward if you have naked characters and then the clothing around them are blueprints.","This is another reason why it's suggested to stay away from blueprints for multiplayer, as with meshes, since they get attached to the actor itself, when it comes time to replicate it theres no snapping or pop-in. All components on an actor are replicated within the same frame.","There is always a chance a packet will be dropped, which is again why you should refrain from blueprints as the engine does a very good job ensuring every mesh component is replicated. For every blueprint, you're adding another actor, and another equipment manager component, and more RPC's and more RepNotify's and each of those have a chance to get dropped."]},{"l":"Events","p":["There are two events that can activate when equipping and unequipping an item occurs.","The first is the component's ItemEquipped and ItemUnequipped delegate. This is only called when an item is added or removed from a slot. This is only called on the actor that the inventory component the slot belongs to, so equipping a weapon as a player will have the delegate call on the player, not the weapon.","Two interface functions also called ItemEquipped and ItemUnequipped from I_Inventory are called whenever the equipment system spawns or updates the status of an item. For example, equipping a gun so it spawns, then holstering it and unholstering it.","If your settings have the item set as a blueprint, these events are called on the spawned blueprint. For example, equipping a weapon as the player will have the interface functions called on the weapon, not the player. The inverse of point 1.","If your settings have the item set as a static mesh or skeletal mesh, the interface functions are called on the player."]},{"l":"Notes on general equipment system design","p":["Equipping and unequipping items can get messy, most importantly it can get messy when players start spamming the system with animations, either by quickly equipping and unequipping an item really quickly or equipping multiple items, all trying to activate montages which will interrupt each other. In the demo, items do not play an animation when equipped or unequipped. But they do play an animation when you holster or unholster an item. If you're in multiplayer, the item will also be added to the network queue to prevent clients from spamming the server with RPC's. By default, there is no failsafe if an animation is interrupted as that is something most designers want to implement their own system into. Some designers might want players to be able to cancel animations or cancel the equip if it was interrupted. It is up to you to implement any sort of failsafe if players are finding ways to manipulate this animation cancelling in ways you don't like.","If you're going to have items visible on your character, it is recommended to have at least one setup for every item that instantly attaches the item to the desired location and mesh. This is so when you load a save, you won't get several animations playing at the same time and overlapping each other."]},{"i":"why-are-all-my-components-getting-renamed","l":"Why are all my components getting renamed?","p":["The system automatically tries to keep all components attached to an actor with unique names. Including attached actors. This is because of how the preview system works. The preview system attempts to reconstruct the actor it's previewing without fully cloning it. There are ways of perfectly cloning an actor, but those are very expensive and come with their own set of problems. The preview system only looks at the visible components on the actor, including attached actors, and reconstructs it. But problems occur if two components have the same name from 2 different attached actors. When the preview system reconstructs the actor, it finds out what component it was attached to, but it needs to know which component that is on itself, it can't use the object reference. This means that if two components have the same name, it'll mess up which component it should attach to. The simple fix to this is to make sure all components have a unique name. The engine already handles this if you attach a component to an actor and that actor has a component with the same name, but it does not do this for attached actors.","But to simplify debugging, only a underscore and a random number is added to the end of it. The rest of the name is untouched."]},{"i":"where-are-the-items-being-created","l":"Where are the items being created?","p":["A separate actor component called BP_AC_EquipmentManager is created and attached to the owning actor to handle the creation of items. This is handled this way because of replication. Before the system was replicated, this component didn't even exist and the system worked just like it does now.","This component is responsible for ensuring items are replicated in the correct order and attaching things in the correct order, in case an item got replicated before the item it is attached to is replicated."]},{"l":"Common issues","p":["Physics is typically the main culprit for the equipment system breaking. If an item or components have physics on by default, they will instantly detach the moment they are initialized. Breaking the entire equipment system. Physics will also cause issues with generated item icons, as that system relies on the attachment hierarchy being correct and detaching things due to physics will break it."]},{"l":"Custom equipment system","p":["It's fairly simple to completely replace the equipment system or use a hybrid solution. To understand the beginning of the chain, the equipment system begins ideally on the actor on the Inventory -> ItemEquipped delegate. This is where you'd inject any modifications to the base behavior of the equipment system.","In some cases, it's simpler to just swap out a mesh with a new one. For example, the player might have a default jacket if no other jacket is equipped. In this case, it's much simpler to just use a custom equipment object which holds that other mesh and swap the default jacket mesh with the new one.","It all comes down to the complexity of your game. The default equipment system tries to cover a lot of different and complex scenarios, thus it has become big and can be overcomplicated depending on the simplicity of your project."]}],[{"l":"Custom Interaction system","p":["The plugin does come with an extremely basic interaction system, which is designed to be replaced. This page covers how to replace it."]},{"i":"27-and-above","l":"2.7 and above:","p":["Simply replace the PreInteract, StartInteract and EndInteract with your own interaction functions inside BP_ItemActor and BP_Interactable. All three functions are inside BPI_Interact, which can be found in the plugins demo folder and removed once these three functions are replaced."]},{"i":"26-and-below","l":"2.6 and below:","p":["There are two functions, StartInteract and FinishInteract. The first will send an RPC to the server, then the server will send the client any data around the component the client needs, then trigger AC_Inventory-> OnDataReceivedFromOtherComponent, which will call FinishInteract. This is handled in this way because allowing players to interact with the actors component before replication is finished can lead to a lot of bugs. Not because there are issues in the plugin, but because of the nature of clients modifying an actor that isn't in sync. Virtually every multiplayer game handles it in this way unless they have client prediction and network rollback. This is the only \"gotcha\" that needs to be kept in mind. In general, you should already not be allowing players to interact with actors that are waiting on an RPC.","With the above point in mind, you can start replacing all the functions with your own. The only ones that other systems rely on are GetAnimationData and UpdatePreview."]},{"i":"color-sheet","l":"Color Sheet:","p":["functions- Variable- category- class"]}],[{"l":"Suggested Plugins","p":["This is a list of plugins that I personally suggest you use alongside this plugin. None of these are mandatory and completely optional."]},{"l":"GAS Companion","p":["Unreal Engine's built-in Gameplay Ability System (GAS) is extremely powerful and is becoming an industry standard. There is a problem with it though; it's very beginner-unfriendly. It's annoying to make attributes and can take a long time to set it up. The plugin GASCompanion does all the heavy lifting for you, has good documentation and good Discord support. I am not implementing a attribute or ability system with this system because I believe you should be using GAS (Either a plugin or your own implementation)."]},{"l":"UnrealImGui","p":["DearImGui is a great tool used in tons of game engines and is amazing for debugging your game. You can get blueprint support through ImGuiBlueprint(I have a personal repo where I've added more widget support) I sometimes use this plugin to quickly visualize data from a bunch of items while in-game."]},{"l":"EditorScriptingTools","p":["This plugin lets you customize the editor without touching C++. This way you can add UMG widget tools into the item data asset all inside blueprints and without touching the plugin."]},{"i":"my-other-free-plugins","l":"My other (free) plugins","p":["I make other plugins to solve problems when I'm making games. These are MUCH smaller and simpler plugins compared to IFP. Some of them are unfinished, some of them might have bugs, but due to their simplicity and small size, the chances of bugs are low and fixing them is pretty fast."]}],[{"i":"how-does-the-networking-work","l":"How does the networking work?"},{"l":"Listeners","p":["Certain inventory data can become quite large, especially with how many containers and items you allow in an inventory. To optimize, we try to simplify things. Players only receive data from components that they request data from and data from their own components, but also any update from components they are currently interacting with.","The component keeps track of the players that are currently interacting with a component with the Listeners array, then whenever PlayerA moves, adds, removes or interacts with an item in some way, the component sends RPC calls to the other \"listeners\" so their widgets and data get updated.","For functions that modifies a components data, such as moving an item or modifying an items stack count or modifying any other data, you must remember that clients only have authority over their own component, they do not have authority over other components and thus can't call functions on other components. This is simply how networking in Unreal Engine works. Because of this, most functions require you to call the function on the component the client has authority over. Even though the item you are trying to modify is not on that component. This is why, when you look at some of the source code, the functions are getting the component the item belongs to through its UniqueID. ParentComponent and modifying that component's data through the component the client has authority over.","To simplify the code, any function that attempts to automate the replication for you stores its logic in a function with the same name but with a Internal_ prefix.","For most functions that modify data in some way, only a single version of that function is available for you to call, and that function handles the replication for you. This is to simplify the amount of functions exposed as it can get very daunting to try and handle every replication scenario and making sure your calling the right function. If you wish to modify how the replication is handled, you can always go into the functions, modify them, or enable the server/client/internal functions to be BlueprintCallable (Example would be AC_Inventory-> Internal_AdjustContainerSize)."]},{"l":"Code example"},{"i":"why-not-just-use-a-multicast-or-repnotify","l":"Why not just use a multicast or RepNotify?","p":["Because of how large some RPC's can get, I did not find multicasts to be acceptable for most of the functions. A lot of the RPC's are just simply not relevant for most clients anyways, and managing relevancy is a lot more complicated than a simple array of actors.","RepNotify's also can not be used because there is no way to ensure their order. When you label a RPC as \"Reliable\", Unreal will make sure all reliable RPC's get replicated in the order you called them. Variables will always get replicated, even with packet loss, so they are in a way \"reliable\", but not truly reliable. Variables will replicate whenever they get an opportunity to, and they have a lower priority than RPC's."]},{"l":"Unique ID","p":["The UniqueID is a simple method to quickly find containers or items, or ensuring containers or items are valid, and for linking some object to an item (Such as the item driver's). This is covered in multiple sections in the documentation, but here are some things to consider for networking.","Clients and servers must stay in sync when it comes to UniqueID's. This leaves you with two options;","Pre-generate the UniqueID's on the server, then pass them to the client and have your logic assign that UniqueID to the item. This is not advised as it can get bad for networking and it is generally cumbersome to program and manage it.","Use GenerateUniqueIDWithSeed. Now the only thing you need to ensure is that the client and server are using the same seed and they'll both generate the same UniqueID.","UniqueID's scale extremely well with RPC's. It is advised to use UniqueID's as often as possible.","There's no way to evaluate from a UniqueID if it was assigned to an item or container without going through all items and containers until you find a match. It is not recommended to add more information to this struct as it's meant to be small and simple, so that it gets replicated extremely quickly and cheaply.","UniqueID's from components the client does not have information on will not work. For example, two players are interacting with a chest and Player-1 moves an item from their inventory to the chest, Player-2 will not have the information necessary to move the item on their side, since they do not have the information needed from Player-1's inventory component. Some functions simply need more information than the UniqueID can provide."]}],[{"i":"how-does-the-system-work","l":"How does the system work?"},{"l":"Design structure","p":["With how strict the performance requirements were for this plugin, I’ve had to design this inventory system slightly differently from other systems you might find either on the marketplace or Youtube tutorials. The biggest thing to keep in mind is that this system does NOT rely on widgets being valid or created to keep track of its data.","This is to achieve five things:","This greatly speeds up widget construction since all the data they need (for example where an item is inside the container and so forth) is already prepped.","Allows you to remove widgets from RAM and still have the necessary data to find out important things like looting an item and finding a free space for that item.","Since widgets have way fewer references, there is less work to be done to manage widgets getting garbage collected properly.","Designers are able to create new widgets and prototype much faster since all the data they need about containers and items is always available from the component.","You have complete control over when you want to construct these widgets, meaning you can reduce lag spikes when starting your game or even speed up the time it takes for your players to load a level or area.","ContainerSettings is an array inside of AC_Inventory.h and it contains all the settings your designers will use and some settings only the programmers will use, and with all the settings combined you can figure out everything about that container.","When creating a widget for a container, the widget uses a UniqueID to find out what container it is representing.","Items differentiate themselves from each other by using a UniqueID as items can have the same name, same data asset and so forth, they can even share the same position inside a container while in-editor. A component can not give items or containers the same UniqueID twice. This is essential for functions to work properly.","The component is designed to live on individual actors, not the player controller. Though there is no reason why it can't live on the controller, but I won't be actively testing it that way.","It is highly recommended to head over to the AC_Inventory page and giving a read. Understanding the main component that makes this system work is crucial to understanding the in's and out's of the system."]},{"i":"how-are-the-infinite-items-inside-of-items-achieved","l":"How are the infinite items inside of items achieved?","p":["TLDR; Containers have coordinates explaining what item they belong to. The array is simply containers and those containers have an array of items. The only thing the compoonent needs to know whether a container is owned by the component or owned by an item is by checking FS_ContainerSettings. BelongsToItem.","I recommend reading the code comment for the container struct and then looking at AC_Inventory.h-> GetItemsContainers for an example."]}],[{"l":"Style Guide","p":["I have tried to follow the popular UE5 Style Guide. Though I may sometimes accidentally or purposefully sway from it. I am very open to criticism, if something is confusing or inconsistent, don't hesitate to let me know."]},{"l":"Functions","p":["Networking functions are prefixed with C_ for client, S_ for server and MC_ for multicast. For functions that attempt to automate replication, the bulk of the function's code is stored in a function with a Internal_ prefix. These are typically called both by the server and client. If you want access to the internal functions, you will need to add BlueprintCallable to the UFUNCTION above them."]},{"l":"Tools","p":["All editor utility widgets are stored inside Plugin folder -> Content -> Core -> Widgets -> EditorUtilityWidgets -> Tools. Any widgets or special components for each editor utility widget is stored in its own folder named after the editor utility widget inside the EditorUtilityWidgets folder. This is done so you can bookmark/favourite the Tools folder and have access to all the tools quickly. You can also find all your editor utility widgets at the top of the editor -> Tools -> Tools, though there is no way to separate the inventory tools from your own editor utility widgets."]}],[{"l":"Classes and Settings","p":["For all the classes that have a blueprint child, it is advised to use the blueprint as your parent for your classes, but is not mandatory. The blueprints have been designed to have children with your own custom logic and design.","All base classes will have a link to their documentation (if available) at the top of their header file or in the Event Graph."]}],[{"l":"A_ItemActor","p":["This is your physical representation of the item. If you already have items/weapons of any sorts, you will want to reparent those classes to this.","This is not supposed to run important logic as these can get destroyed and created by the user. (for example equipping and unequipping)","In your data asset, you can access this class so whenever you drop the item out of the inventory or want to spawn it in some way, here is how you access the original pickup class.","It’s very important when making your items that have a physical representation in the world and can be picked up that the component on that actor references the data asset that references this physical actor. Otherwise when you drop the item, it’ll spawn the wrong class.","The setup for pickups goes like this: In your ContainerSettings index 0, you set ContainerType to ThisActor and item index 0 is the pickup data asset. There should be no other items in this items array. Containers that might be attached to the pickup are added after and they can have Inventory or Equipment selected, but never CurrentItem."]},{"i":"c-item-actor","l":"C++ Item Actor","p":["File location: InventoryFrameworkPlugin\\Public\\Core\\Actors\\Parents\\A_ItemActor.h File location: InventoryFrameworkPlugin\\Private\\Core\\Actors\\Parents\\A_ItemActor.cpp"]},{"i":"blueprint-child-bp-itemactor","l":"Blueprint Child: BP_ItemActor","p":["File location: Content\\Core\\ActorParents\\BP_ItemActor.uasset"]},{"l":"Custom Blueprint Children","p":["The BP_ItemActor is a optional parent in your hierarchy. It has some code that you will want to copy over to any parents that you have if you wish to make your own, primarily the BeginPlay, Equip and Unequip delegates, and Destroyed event.","The C++ inventory compoonent will automatically get added to your actor, but the base C++ version should not be used. You want to click on the InventoryComponent in your components list and set ComponentClass to BP_AC_Inventory (Or your own child of the inventory component if you've made one)"]}],[{"l":"AC_Inventory","p":["This is where the vast majority of the logic is handled and starts. You have full control of when the component activates by calling the StartComponent function. When called, the component initializes the containers and the items inside or the pickup if the owning actor is a pickup. This does NOT prepare the widgets versions of the containers and the items. But this function must be called before you display any widgets or any data to the player.","To create the widget version of a container and its items, call BindContainerWithWidget and hook in the container struct and the container widget. This should give you full control of when you want to construct the widget for a container. Some examples would be when the player opens their inventory, but you don’t want to load all the items' attachment widgets. You could then load the attachment widgets when the player inspects the item. For inventory systems that can get massive with a lot of items inside of it with attachment widgets associated with it, this massively improve performance and memory usage if used correctly.","For pickups, I recommend calling StartComponent on either BeginPlay or when the player is close to the item and has line of sight of the item, as items that have a spawn chance associated with it need that spawn chance rolled. The item might also have items attached to it and be visible, such as a sight on a gun, which also might have a spawn chance and you don’t want that sight to be visible if it failed its spawn chance."]},{"l":"Actor Component Inventory","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Components\\AC_Inventory.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Components\\AC_Inventory.cpp"]},{"i":"blueprint-child-bp-ac-inventory","l":"Blueprint Child: BP_AC_Inventory","p":["File Location: Content\\Core\\Components\\BP_AC_Inventory.uasset"]},{"l":"Settings","p":["The first category is Settings and most of these are instance editable, so you’ll be spending most of your time with these settings for your item actors.","ContainerSettings is where the majority of the work is done. I recommend going into IFP_CoreData.h and find FS_ContainerSettings and looking at the comments for everything as there are some variables that aren’t instance editable."]},{"l":"User Settings","p":["The second category is UserSettings and these are settings that are meant to be used by the player during runtime. It’s up to your settings system to update these if you want the player to be able to change these settings during runtime. The input system is extremely basic and is meant to be replaced. They are never used at a C++ level, so your designers can replace it easily. RotateKey: While dragging an item, the player might want to rotate an item. When they press this key, it’ll rotate. SplitKey: While dragging a stackable item, when they drop the item onto a valid tile, they can split an item into two stacks."]},{"l":"Color settings","p":["Third category is ColorSettings and this is where most of the colors used by the system are dictated. This is set in here so all the widgets can fetch colors easily and so designers can extend any color settings (for example color blind settings) to the user settings. If you want to add any color settings, this place is the preferred place. Item rarity colors are handled in here."]},{"l":"Network Queue","p":["The component has an array called NetworkQueue, these are items that are waiting for a server RPC to finish. If you are writing your own networking code, it is up to you to call C_AddItemToNetworkQueue and C_RemoveItemFromNetworkQueue. This will automatically call ItemAddedToNetworkQueue or ItemRemovedFromNetworkQueue.","If the item widget is available, it'll also call: W_InventoryItem-> ParentItemAddedToNetworkQueue/ ParentItemRemovedFromNetworkQueue","These events are where your designers hook in any logic that alerts the player the item is pending some networking event. This is most often seen as making the item's icon gray-scale or flashing the icon.","You will want to implement some way of preventing players from interacting with items that are pending a network event, either by making the widget uninteractable or through code. You can check if an item is in the queue by using: FL_InventoryFramework.h-> IsItemInNetworkQueue","The Network Queue system is only relevant for clients, it's never used in single player or server scenarios."]},{"l":"Infinite containers","p":["Containers can be infinite in either the X or Y direction, the system tries to dynamically resize the container whenever an item is moved, added or removed from it."]},{"l":"States","p":["The containers can be in one of three states during development.","The \"raw\" state is where UniqueID's are not set and containers BelongsToItem directions are direct index directions and all object references are null. The component is designed to be in this state for when you call the StartComponent function. This is where all the data is \"human readable\", but most functions won't work.","The \"Editor\" state is where Unique's have been initialized and BelongsToItem are set to the items and containers UniqueID's and some object references might be valid. This state is meant for development and it might make some data not human-readable, and it'll mean most of your functions will work as if you are in a valid game session. Many tools depend on the component being in this state, such as the InventoryHelper.","Finally there's the \"Initialized\" state. This simply means the gameplay logic has called the StartComponent function and you are inside a gameplay session. The component should never be put into this state while you're outside of a game session.","You can use GetComponentState to resolve what state it is in, and look inside that function to better understand what conditions must be met for each state.","There is a function called ConvertToRawState which will prepare all containers for a gameplay session. Ideally, this function should not be called during a gameplay session as it's a waste of CPU time. All container data should already be prepped for gameplay. By default, the component calls this function on its BeginPlay if it detects the actor was not setup properly and spit out a print string. There is also another function called ConvertFromRawStateToEditorState which preps all data to be usable for editor tools."]},{"l":"Attached spawned items","p":["An important aspect to remember is that whenever you have a item that has a spawned actor to represent it, such as a gun item inside the players equipment container, the inventory component on the spawned item should NOT be used.","This will mostly happen with the equipment system when using Blueprint items. The reason for this is because spawned blueprints can be deleted and restored over and over, so they are unreliable to store any important data. It would also mean that the blueprint would always have to stay alive if you wanted to explore the items containers while the item isn't spawned (In this example, the gun item hasn't been equipped). An items containers always live on the component that own the item, (In this example, the gun's containers live on the character that is holding the gun).","To retrieve the items true data, you need to retrieve the UniqueID of the owning item in some way. Generally this means storing the items UniqueID inside your spawned blueprint. BP_ItemActor does this through an interface event called PassUniqueID and stores the data inside RootItemData."]}],[{"l":"BP_PreviewActor","p":["This is an actor that “should” perfectly duplicate the appearance of any specific actor. It does this by getting all components of the owning actor and then duplicating it and reconstructing the hierarchy structure to match the hierarchy structure of the owning actor. This includes any attached actors.","It currently supports SceneComponent, PrimitiveSceneComponent, ChildActorComponent, StaticMeshComponent and SkeletalMeshComponent.","It should be easy to add compatibility for more components, you’ll have to add them yourself, but the currently supported components should support the vast majority of components that have any sort of visual importance. You can optimize the construction or simply prevent this actor from duplicating a specific component by going into ComponentTags and adding “ DONOTPREVIEW”. Though remember, since the actor is trying to reconstruct the hierarchy setup inside your original actor, any components attached to components that you labeled as “ DONOTPREVIEW” will break.","This actor will render out a render target for you to use however you wish and this is how the item icon generation is handled.","Even though the render scene component only see’s the preview actor itself and it only receives lighting from lighting channel 1 (Channel can be changed, but it’s recommended not to have it on 1 if your game has day/night cycles), BP_PreviewActor’s lighting can still affect another BP_PreviewActor. Even while spawning them at a ridiculously long range of random locations, during my playtesting I still had this scenario happen. To fix this, there’s a BP_PreviewActorCollider which you will spawn first, which will test for collision and adjust its location. Then you spawn BP_PreviewActor itself and set its location inside the collider.","This does mean though that you need to handle the collision responses for this. I recommend creating a new collision channel for BP_PreviewActor and BP_PreviewActorCollider."]},{"l":"Blueprint Preview Actor","p":["File Location: Content\\Core\\Preview\\BP_PreviewActor.uasset"]},{"i":"notes-regarding-span-style-color-violet-childactorcomponent-span-s","l":"Notes regarding <span style=\"color:violet\">**ChildActorComponent**</span>'s","p":["There is currently no way to disable BeginPlay, where as with Actor's you can with a ExposedOnSpawn boolean at the beginning of your BeginPlay logic. If you have any logic connected to your BeginPlay, you will need to find a way to disable it for the preview if there's any logic you don't want the preview to run.","If possible, avoid ChildActorComponent's. They are extremely prone to bugs and odd behaviour, and they don't seem to play well with networking."]},{"l":"Camera management","p":["The BP_PreviewActor will attempt to find the first component which has a socket called “PreviewCameraSocket” and attach the camera to that socket. If none is found, you’ll get an error message and the camera will stay attached to the PreviewActor’s root. Ideally, all your meshes should have this socket that you want to use this actor on. But to improve prototyping, I’ve added a few options to the item data asset:","Once you're far enough into production or willing to keep all meshes up to date with the socket, you should remove these four settings.","The actor supports auto-generated estimated camera distances, so you don’t have to debug every item to create a camera distance while in a prototyping phase. You can disable this by checking Use Custom Arm Length."]},{"l":"Skeletal Meshes","p":["The default animations for skeletal meshes is retrieved via an interface function GetEquipmentData. This allows you to assign what animations the previewed skeletal mesh will play. For now it is only looping one animation, but an animation blueprint can be added to this struct if you wish."]},{"l":"Optimizations","p":["It is also up to you to manage the render targets and when they should be released from the GPU. You can see an example in WBP_InventoryItem-> TryReleaseGeneratedIcon. I’ve tried to automate the release and creation for the widgets that come with this plugin, but if you are making a new widget and are new to render scene components, you must call ReleaseRenderTarget2D for the texture.","It is hard to create a perfectly automated system, so if you ever encounter an icon vanishing for an item, that means the render target was released improperly. During your prototyping phase, I recommend you just release and wipe the references when the player closes their inventory. Then when you’re in your optimization phase, you can try to optimize this. Do keep in mind that live captures can get very expensive, very quickly, since they are capturing a new image every frame.","You can limit it by enabling CaptureEveryFrame and limiting the TickInterval inside of SceneCaptureComponent2D.","I have these disabled by default, so if your actor isn’t animating, you need to enable CaptureEveryFrame, or if you're duplicating an item, you can go into its data asset and disable UseStaticCapture.","Any actor being fed into the preview actor should avoid skeletal meshes as much as possible, as they are approximately 50 TIMES more expensive than most other components to clone."]},{"l":"Leader Pose","p":["To bind two meshes together, you will have to setup their component tags in a specific way. The leader must contain some tag, in this example we'll use PlayerMesh. Skeletal Meshes that now want to assign that mesh as their leader pose will then want to add a tag containing the word: LeaderPose: PlayerMesh."]},{"l":"Common issues","p":["Physics is typically the main culprit for the preview system breaking. If an item or components have physics on by default, they will instantly detach the moment they are initialized. Breaking the entire preview system. Physics will also cause issues with the equipment system, as that system relies on the attachment hierarchy being correct and detaching things due to physics will break it."]}],[{"l":"DA_CoreItem","p":["This is the data asset that is responsible for the base information for your items. I highly suggest looking at the DA_CoreItem.h file to see all the settings, functions and comments.","You can show and hide certain settings depending on your setup, and I use that a lot with the ItemType enum. Look at all the options, check out the meta properties (EditCondition and EditConditionHides) to see how it’s done, and you can then implement your own options and rulesets for their visibility.","Keep in mind, these settings are only HIDDEN, not disabled in the data asset editor, you can still access those variables from the data asset in blueprints and C++ and you have to remember that when making your functions and gameplay logic. One of the most important settings to set up here is EItemType as many functions use this enum to do casts to the proper children of this asset. Whenever you make a new child, remember to go into the .cpp file and set the default value. You can see an example inside all the .cpp children of this.","If you are new to C++ or Unreal Engine, I suggest looking here to find all the specifiers you can give each variable."]},{"l":"Data Asset Core Item","p":["File location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Items\\DA_CoreItem.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Items\\DA_CoreItem.cpp"]},{"l":"Changing the Item Actor class","p":["Currently your item actors must be a child of AA_ItemActor. If you want to change this, you can change it like so:","AActor can be swapped out for any class, it does not need to be AActor, but it must be a child of AActor."]},{"l":"Custom shapes","p":["This inventory system features container styles where items can be different lengths and different heights. The way you define your shape is by adding the Custom Shape object to your ObjectsAndDrivers array and using the DisabledTiles array. Though this is not very pleasant to work with in its raw array format. It is recommended to use the ItemEditor, where you'll find a toolbox with a few tools inside of it, one being the shape editor. Which gives you a much better UI to work with."]},{"l":"Asset verification","p":["To aid quality assurance, the data asset will run custom data verification when the asset is saved. The verification validates everything in the following process:","Use the ValidationClass in the DeveloperSettngs category to execute its VerifyData function. (Because we can't access a blueprint graph in each instance of a data asset, we do this to get around that limitation.)","ValidationClass-> VerifyData will run some code to check if any mistakes have been made. Since every project is different, it is suggested to create your own child of O_ItemAssetValidation and write your own code. To validate the data of object references, an interface function from the I_Validation.h interface also named VerifyData is called. You can see an example of this inside of O_BasicItemValidation and IO_Consumable","If any error messages are created during any of the VerifyData functions, you'll get a message at the bottom right stating the error message. If the ErrorMessages array is empty, the item passes the verification.","Do note, if an item does not pass the verification, it does NOT prevent you from playing the game."]},{"l":"Where to store runtime logic","p":["As the plugin has grown, more and more features have been added, blurring the definition of what an \"item\" is and where any gameplay logic should be stored.","All items are data assets. Then when the inventory is made, a struct is made, which contains all data that can be modified during runtime and this data is replicated under specific conditions.","Data inside of data assets should NOT be modified during runtime. If you have 2 guns in your inventory, then change any data inside the asset, it'll change for both of the guns. But modifying the struct for a gun will only modify that specific struct.","The four primary options below leave you with many options to tackle where to store your data and logic. It's up to you to resolve which method is best for what you are trying to accomplish."]},{"l":"GAS abilities","p":["What I, and many others have been doing, is simply constructing one object, a GAS ability, and having that run the logic for, let's say, a gun item. Whenever you swap weapons, you'd just send an event to the ability and it would update what weapon is equipped. This has many performance benefits, quality of life benefits, many more features, and much better networking options. Overall, I would recommend using GAS over all other options whenever you can, but of course, not all use cases are the same. There is no ultimate solution that covers every scenario.","I personally recommend using GAS Companion and/or Gameplay Blueprint Attributes to help with your GAS implementation."]},{"l":"Objects and drivers","p":["https://inventoryframework.github.io/classes-and-settings/o_itemobjectandac_itemdriver/ Data assets have \"objects\" and \"drivers\", which I recommend you read the documentation for, but in essence, they are:","Objects: Extra data you can add to any specific asset without creating a new parent. Essentially giving you \"horizontal\" hierarchy, just like how interfaces add functions to a class without reparenting it.","Example: You have a sword and a health potion asset. Both of these can be crafted, but you don't want to create a \"Craftable\" item asset to insert into their hierarchy. Not all swords and not all potions might be craftable. You can now add an object to any asset that has a recipe and have that object link to that recipe data asset. You can now ask your data asset if it is \"craftable\" without asking your entire recipe data base if it has a recipe for that item.","Drivers: Actor components that can be created during runtime and are attached to the same actor that the inventory component lives on. These can run gameplay logic and destroyed during runtime, just like any other actor component. These are tied to objects so they can also be thought of as \"horizontal\" hierarchy."]},{"l":"Item actor","p":["Then there's the optional actor to spawn when the item is dropped, or in some cases equipped. These can be destroyed and created frequently, so it shouldn't really be trusted with a lot of gameplay logic. This should be treated as just the \"visual representation\" of your item."]},{"l":"Item Struct Object","p":["Finally, there's the \"struct object\". This is simply an optional object that is created when the item struct is created and are then tied together. Unlike the actor, this can be trusted with gameplay logic. It is only destroyed when either you explicitly destroy it or when the item itself is destroyed.","Do note that this class is hard referenced by the item asset. Be mindful of your hard references.","These are instance editable. Meaning that the same class can be used for each item asset, but you can modify the variables in the item asset. When the struct object is created, it'll inherit those settings automatically.","There's two ways to initialize these objects. One is inside the data asset. This is the default object that will be used. But each struct instance can override either what class to use, or change the variables to more suit that specific instance.","I highly recommend that you do not start mixing the classes used these structs for a specific item. For exameple; two apples using a different object class can lead to a lot of confusion and messy code. I'm not going to put any restrictions on this, some projects might need this, but it's a consideration to keep in mind.","Full replication support.","Experimental: These objects can be serialized. They will only restore any variables using the SaveGame flag (in blueprints, it can be found in the Advanced section in the details panel when you have a variable selected). Since this is experimental, it is not recommended to use for production. The serialization function might change in a future update, leading to old save files not being compatible with the new function. It will also only save the players struct objects, not other actors struct objects, and that will likely stay like that. There are hundreds of more things to consider with serialization than just the inventory and there are better solutions on the marketplace from people who properly understand serialization."]},{"i":"when-are-they-created-and-destroyed","l":"When are they created and destroyed?","p":["Struct objects are created during StartComponent and are tied to the item until the item is destroyed.","The object will remain alive until the garbage collector kicks in, just like how widgets and many other objects work. You can use IsDestroyed to check if the object has been destroyed or not."]},{"i":"how-does-the-networking-work","l":"How does the networking work?","p":["Objects are replicated to all clients that are relevant to the owner of the inventory component. But the item data is not replicated and even if it was, it should NOT be trusted on clients that are neither the owner of the inventory component or the server. This is because of how IFP optimizes networking, which can be read further about in the Introduction section.","Experimental: These objects can declare their own replication condition, giving you a chance for massive networking improvements. This means you can have objects that only replicate to the owner, server only, or you can even disable replication."]},{"l":"Performance","p":["Constructing these objects is cheap, but if you plan on using hundreds of these, the small cost can pile up. The main worry you might need to consider is the garbage collector. The developers of Hogwarts Legacy had this problem where they abused instanced objects that the garbage collector would cause hitches, though I am not sure as to how many objects they were making. I suggest only making these objects for items that actually need it."]}],[{"l":"O_ItemObject and AC_ItemDriver"},{"l":"Object Item","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Objects\\Parents\\O_ItemObject.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Objects\\Parents\\O_ItemObject.cpp"]},{"i":"blueprint-child-bp-o-itemobject","l":"Blueprint Child: BP_O_ItemObject","p":["File Location: Content\\Core\\ActorParents\\BP_O_ItemObject.uasset"]},{"l":"Actor Component Item Driver","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Components\\AC_ItemDriver.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Components\\AC_ItemDriver.cpp"]},{"i":"blueprint-child-bp-ac-itemdriver","l":"Blueprint Child: BP_AC_ItemDriver","p":["File Location: Content\\Core\\ActorParents\\BP_AC_ItemDriver.uasset"]},{"l":"Objects","p":["These are pure UObjects which are accessible from the items data asset. Each object's variables can be modified per data asset, allowing you to add any variables or functions to any data asset, regardless of their parent data asset.","You can then retrieve this data by using the GetObjectsByTag/ GetObjectsByClass. The class version will automatically cast to the correct blueprint. For the tag version, you manually have to cast to the object.","There are two types of objects, pure objects, which are data-only, then there are objects designed to go alongside a driver."]},{"l":"Data-only objects","p":["While you can add those variables to the data asset itself, some people do not want to go into C++ OR there is some data that can't be categorised to an item category. For example; quest data. Any item can be a part of a quest, but you might not want create a data asset parent dedicated to a quest category.","These objects can also run functions, but share the same limitations as data assets functions. These functions can not have delays, timers, async tasks or RPC’s. Do not write any data to any variables belonging to the Object as every item with the same data asset shares the same Object. A unique Object is NOT created per item."]},{"l":"Drivers","p":["These are actor components that are meant to drive any gameplay logic related to an item, such as equipping an item, consuming an item, creating a widget and so forth. These can be assigned to an item through any object that is a child of O_ItemObject.h. Every driver needs an object to work, hence why there's a documentation page for each individual class, except for this class. Drivers are tied to objects. But every object does not need a driver.","These components can also be viewed as a proxy between the inventory system and any other system. These ItemObject and ItemDrivers have been designed to be extremely abstract, so you can modify them however you want without it affecting how the inventory works. There's very few aspects of the inventory that depend on this system.","They work just like any other actor component, they can have delays, timers, RPC's and so forth. They also have methods of following the item it is bound to where ever it goes and retrieving the item data.","ItemDrivers have three replication methods; Server, Client and Both. Server ItemDriver's only exists on the server, client ItemDriver's only exists on the client, and Both are created on the server and replicated to the client. You’ll most likely be using Both most of the time. Clients are able to request the creation of an ItemDriver and pass in a tag, which you can associate with a function. This prevents those pesky situations where you are working on client code, for example a widget, and are trying to activate a function inside an item driver. The function GetItemDriver will create the driver for you, but if you are on the client and trying to create an ItemDriver set to Both, the function won’t be able to return it, because it has to send an RPC to the server which is not instant.","This function allows you to pass in a tag which will trigger any function you have associated with the tag once the ItemDriver is replicated. Look at the code comment for AC_ItemDriver.h-> ActivateEvent. If you are unfamiliar with GameplayTags, I highly recommend you start using them as they are extremely useful.","Whenever possible, use soft references and try to avoid hard references. Item data bases are one of the fastest ways of creating a nasty web of hard references and before you know it, the majority of your game is loaded at times where you don't want it to be. These objects are potentially the biggest culprit in this system to create that kind of nasty web of hard references."]},{"l":"Tips and tricks","p":["By default, your objects will display their default class name in the drop down menu.","You can change the name they are given inside this drop down menu by following the next steps.","By going into your Class Settings (1) you can change the class name (2). The drop down menu will now display whatever text you put in here."]}],[{"l":"W_Attachment Parent","p":["The parent widget for widgets that are used to hold the containers an item owns. For example, a gun has a sight and a magazine slot and you want to represent those slots with a container. That container needs to be hosted by some widget.","The base widget does not have any kind of layout so you are free to make any layout your project needs.","Both the C++ parent and the blueprint child are abstract, so it won't appear in any drop-down menus. These are designed for the intention to have children made from them."]},{"l":"Widget Attachment Parent","p":["File Location: Source\\InventoryFrameworkPlugin\\public\\Core\\Widgets\\W_AttachmentParent.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Widgets\\W_AttachmentParent.cpp"]},{"i":"blueprint-child-wbp-attachment","l":"Blueprint Child: WBP_Attachment","p":["File Location: Content\\Core\\Widgets\\WBP_AttachmentParent.uasset"]}],[{"l":"W_Container","p":["This widget is responsible for holding both the tile widgets and item widgets and also acts as a proxy for the component to access any tile widgets or item widgets. The component ( AC_Inventory) should not rely on these widgets at all for any data for its functions, like I mentioned at the start of this documentation.","Even though there are ContainerSettings inside of these, they are immediately overridden by the component when created. They are mainly used as a fallback default, used for previewing how the container will look or used to bind the widgets to a specific container in a component. I recommend looking at the comment on GetContainerSettings.","To reduce the work for everyone when modifying containers, W_Container has a function ( GetContainerSettings) to get the ContainerSettings straight from the component it belongs to. This way you do not have to update the ContainerSettings for the widget every time the container is modified in any way and also allows designers to make children of W_Container and still have access to the same data as other children.","TileSize refers to how large you want your tile widgets to be. Ideally both dimensions should be the same to minimize stretching. If you decide to not have the dimensions 1:1, your item icons will have to accommodate for your new icon ratio. Yclamp refers to when you want the scroll bar to appear. This should be (Your Tile Y Size) * (How many Y tiles you want until the scroll bar appears) So if I want mine to appear after 8 tiles while my container is 10 tiles tall and my tile Y size is 60, I would do 8* 60.","TileClass and ItemClass are the default classes used to create the widgets for each instance of a container. It is recommended to try and keep these the same where ever your containers are to try and maintain consistent visuals through out your game.","DA_CoreItem has a override map, where if the current containers class is found in that map, it'll then use the item widget in that map instead of the assigned ItemClass. This could be useful for when a special item needs it own item widget."]},{"l":"Container","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Widgets\\W_Container.h File Location: Source\\InventoryFrameworkPlugin\\private\\Core\\Widgets\\W_Container.cpp"]},{"i":"blueprint-child-wbp-container","l":"Blueprint Child: WBP_Container","p":["File Location: Content\\Core\\Widgets\\WBP_Container.uasset"]},{"i":"demo-widget-wbp-democontainer","l":"Demo widget: WBP_DemoContainer","p":["File Location: Content\\Demo\\Widgets\\WBP_DemoContainer.uasset"]}],[{"l":"W_Drag","p":["Visual representation of the item you are dragging, but also provides updates to W_Highlight whenever you hover over a tile so the highlight widget knows where to move.","All data you need when dragging and dropping an item should be stored in this widget.","Both W_Drag and W_Highlight are updated inside of WBP_Tile-> PerformDrop and BP_AC_Inventory-> UpdateHighlight","The chain of events begin at WBP_InventoryItem-> OnDragDetected. An important note to consider is that Epic, in their ever-ending glorious top tier coding, have a built in interpolation for the drag and drop drag visual that you CAN NOT interact with without modifying the engine. But you have to go through a lot of trouble to replace the built-in drag and drop system for Unreal. So I leave the drag visual for the drag/drop operation as empty and allow WBP_Drag to drive the visuals and most of the logic. The Drag/Drop operation is primarily just used to trigger the \"On Drop\" events."]},{"l":"Widget Drag","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Widgets\\W_Drag.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Widgets\\W_Drag.cpp"]},{"i":"blueprint-child-wbp-drag","l":"Blueprint Child: WBP_Drag","p":["File Location: Content\\Core\\Widgets\\DragAndSplit\\WBP_Drag.uasset"]},{"l":"Rotation","p":["This widget is the primary handler of certain settings when trying to move an item, such as the rotation. You can see an example on EventTick. If you wish to permanently change the system to no longer support 180 and 270 rotation, there is a code comment near the end of EventTick explaining how to enforce only 0 and 90 rotation."]}],[{"l":"W_Highlight","p":["This widget is the primary method used for handling the highlight for moving items. An alternative method is used inside the InventoryHelper tool."]},{"l":"Widget Highlight","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Widgets\\W_Highlight.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Widgets\\W_Highlight.cpp"]},{"i":"blueprint-child-wbp-highlight","l":"Blueprint Child: WBP_Highlight","p":["File Location: Content\\Core\\Widgets\\DragAndSplit\\WBP_Highlight.uasset"]}],[{"l":"W_InventoryItem","p":["These are the widget representations of your item.","The GetItemData function automatically gets the direct struct version of the item it is representing from the component the item belongs to. This is so we don’t store the same item information in two places and whenever the item is updated you don’t need to update the widget as well.","This should allow for more designer friendly architecture, as you could make two children of this widget, one for example the normal inventory item widget the player has in their inventory and then another for vendors and you could have them store items in a list format and things would still work together.","WBP_InventoryItem-> GenerateItemIcon is where icon generation is handled. It’s pretty straight forward, copying the behavior to other children should be simple. It uses the BP_PreviewActor to achieve this. The data asset editor window has a UI category which has various settings to adjust or optimize the generated icons."]},{"l":"Widget Inventory Item","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Widgets\\W_InventoryItem.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Widgets\\W_InventoryItem.cpp"]},{"i":"blueprint-child-wbp-inventoryitem","l":"Blueprint Child: WBP_InventoryItem","p":["File Location: Content\\Core\\Widgets"]},{"i":"demo-widget-wbp-demoinventoryitem","l":"Demo widget: WBP_DemoInventoryItem","p":["File Location: Content\\Demo\\Widgets\\WBP_DemoInventoryItem.uasset"]}],[{"l":"W_Tile","p":["There is very little logic or variables handled in this widget, as you have to keep in mind that this widget can end up with hundred copies or more, so it can get bad for memory allocation if overdone and if you don’t manage the variables those tiles are initializing.","Creating these tiles is by far the most expensive process I’ve found in this component. It is essential they store as little data and perform as few functions as possible so we can optimize the construction cost."]},{"l":"Widget Tile","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Widgets\\W_Tile.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Widgets\\W_Tile.cpp"]},{"i":"bluerint-child-wbp-tile","l":"Bluerint Child: WBP_Tile","p":["File Location: Content\\Core\\Widgets\\WBP_Tile.uasset"]},{"i":"demo-widget-wbp-demotile","l":"Demo widget: WBP_DemoTile","p":["File Location: Content\\Demo\\Widgets\\WBP_DemoTile.uasset"]}],[{"l":"WBP_ContextMenu","p":["This widget is a good example of a widget that is completely separated from the system, but just uses the item data to interact with the inventory system. You can manage the rules for each button and when they should be visible."]},{"l":"Widget Blueprint Context Menu","p":["File Location: Content\\Core\\Widgets\\WBP_ContextMenu.uasset"]}],[{"l":"WBP_Drop","p":["A simple widget that handles dropping an item. There’s nothing special about this, the context menu widget also has a drop function.","The widget simply sets the drop operation enum to DropItem","This causes DropItem function to get called by the component, which could look something like this"]},{"l":"Widget Blueprint Drop","p":["File Location: Content\\Core\\Widgets\\DragAndSplit\\WBP_Drop.uasset"]}],[{"l":"WBP_Split","p":["Created by the drag widget when the player holds the split key. User is able to use the slider to decide how much they want to split an item, then the widget creates a new item with the selected amount."]},{"l":"Widget Blueprint Split","p":["File Location: Core\\Widgets\\DragAndSplit\\WBP_Split/uasset"]}],[{"l":"Adding new items during runtime"},{"l":"Single player","p":["Adding new items during runtime for single player is no problem and has no restrictions. Just call the function AC_Inventory-> TryAddNewItem."]},{"l":"Multiplayer","p":["For multiplayer though, I've had to wrap this function with a very strict safe guard. Clients are under no circumstance allowed to call this function. If they do find a way, they will get kicked. There is simply no circumstance where the client should even have the slightest chance of gaining access to this function as they could potentially feed it bad data and grant themselves any item within your data base.","Only the listen server or dedicated server is allowed to use this function.","This means if you have a quest system or anything of the sort where the player is granted an item, you will have two options:","Pre-store the item in a component and call the MoveItem function, but this will permanently remove the item from the old component. Though you could always reset the data after the function is called.","The system which is calling TryAddNewItem is already owned by the server, and thus is allowed to call the function."]},{"l":"Example","p":["Here is an example of adding a backpack to another component with another backpack inside of it, and that backpack having items inside of it. If your item has no containers, just make an empty array for the ItemsContainers"]}],[{"l":"Creating custom functions","p":["Once you’re comfortable enough in the system to make your own functions and/or change the current functions, here are some things to keep in mind.","You should always assume an item does not have a widget version of itself. If you need access to the widget of an item, you can use GetWidgetForItem. Remember to check if the widget is valid. Widgets also can’t be transported through a network, so if multiplayer is important to you, your server functions can’t rely on data from widgets."]},{"l":"Finding Items","p":["Finding an item is a very common scenario when you start making your own functions.","The container's TileMap combined with an item's UniqueID is the most reliable way of finding items.","The component includes a function to get an item at item at a specific index of a container called GetItemAtSpecificIndex, then there is a bit more expensive way of finding an item but it’ll go through all containers, GetItemByUniqueID.","The UniqueID is the most reliable method of finding a very specific item, container or item driver, other than a direct reference to the item, container or item driver, but even then a direct reference might get outdated if the player moves the item or modifies it in some way. The UniqueID is only updated for containers and items if they are moved to a new component.","W_Tile also have a reference to the item on top of them, but to reduce memory, tiles have a OwningItem integer which references the top left tile of the item, which holds the ParentItem reference variable. So if you are inside the W_Tile and need to get the item it contains, you would use ParentContainer-> Tiles[ParentTile] -> OwningItem-> GetItemData. Remember to check if ParentTile is -1 first, as that means this tile widget doesn’t have any item inside of it."]},{"l":"Network optimizations","p":["It is recommended, where ever possible, to use the item or container UniqueID instead of the struct in your RPC calls, and then have your server use the UniqueID to figure out which struct to use.","Here you can see 2 sets of RPC calls. One is ReduceItemCount(indicated in red), which is passing the item struct to the server and then to the client. The other is IncreaseItemCount(indicated in blue), which is passing the UniqueID to the server and the server is then using that UniqueID to resolve what item we are trying to modify.","Switching to using the UniqueID method reduced the RPC size from around 75 bytes down to 13.","The only downside is that it is not possible to verify if the client has illegally modified it's data, and it's very difficult to verify that the data inside the item/container are synced. It is up to you whether that is a big enough problem to do this. Some anti-cheat methods already do a very good job at preventing clients from modifying the games data with external tools. If you need to validate the data, you can have the server function still accept the full item/container struct, validate the data, then only pass the UniqueID to the client.","We covered that UniqueID's scale extremely well on another page, but to give you an idea of how well it scales, here's an example","These are two functions using an array with 5 entries of S_UniqueID's (Blue) and an array with 5 entries of S_InventoryItem(Red)"]}],[{"l":"Creating custom widgets"},{"i":"containers-tiles-and-items","l":"Containers, Tiles and Items","p":["These three widgets are the ones you'll most likely end up working with the most. To improve the hierarchy, I've tried to not add any components that aren't necessary. Those that are essential for the widgets to function, I've added Getter functions that request the essential widget. This way you're design hierarchy can be in whatever design you want and still use the parent widgets. But this does mean you need to override those functions and passs the widget through as a variable.","All three are abstract, so you must either use the widgets in the demo folder or make your own children.","Technically, these requirements can be ignored, depending on what features you need and don't need, but you might get some errors. For example; size boxes aren't really required as you can set the sizing on the image, but it requires a bit more work to setup correctly."]},{"l":"Containers","p":["Border is needed for scrolling support and sizing ( GetBorder)","ContainerOverlay holds the item widgets ( GetOverlay)","Grid panel holds the tiles ( GetGridPanel)","(Not mandatory, but is recommended) - Scroll box is needed for scrolling ( GetScrollBox)"]},{"l":"Tiles","p":["(2.6 and below) Size Box to control the size ( GetSizeBox)","(2.7 and above) There are no requirements in the tiles hierarchy. You don't even need an image! To control the sizing of the widget, a function called SetWidgetSize should be overriden and handle the sizing logic from there."]},{"l":"Inventory Item","p":["size box to control the size ( GetSizeBox)","Image for the item icon ( GetImage)","(Not mandatory, but is recommended) - Loading Throbber for indicating the item is loading ( GetLoadingThrobber) This widget is updated through the I_ExternalObjects interface. You can see an example of how these updates are used inside WBP_DemoInventoryItem.","The hierarchy inside your custom widget can be structured in whatever way you want, but they must contain the above mentioned widgets inside the hierarchy. Nearly every function inside these widgets are designed to be overriden for maximum customization.","It is advised to read the External widgets page to understand the I_ExternalObjects interface."]}],[{"l":"Creating new items","p":["Video documentation","Creating new items is very simple. To start off, you'll need to go into the engine and find your content browser, right click and go to Inventory Framework -> Inventory Item Asset and a pop up will appear asking you what parent your data asset should derive from. You might have your own children or have removed some of the children that come with the asset, but whatever asset you choose must derive from DA_CoreItem at some point in its hierarchy.","I suggest creating a folder for your item and placing the data asset in there.","To create a blueprint actor for your item, you will have to create an actor who at some point in its hierarchy is a child of BP_ItemActor, then set that as your ItemActor","The actor will automatically get the blueprint inventory component assigned to it. You will need to go into the component settings and change a few things.","Set InventoryType to \" Pickup\"","Add one index to ContainerSettings and set the ContainerType to \" ThisActor\". This will then hide most of the settings except for the items array.","Your items array should only have one index, which will be your newly created data asset. All settings can be left to their default.","(Optional) If your item has containers associated with it, the data asset should have an array of DefaultContainers. You will want to populate these with your containers and also assign the widget. This variable only exists for weapon and equippable item types. An example can be found in the example project with the gun and backpack item.","To have the asset manager pick up your data asset, it can not be identical to another data asset. (This includes the base file, so if all your variables are set to default, the asset will not get picked up.) Typically you want to immediately give your item a name and a developer image for the InventoryHelper."]},{"i":"creating-new-c-children-of-da_coreitem","l":"Creating new C++ children of DA_CoreItem","p":["You might want to create your own category of items, and since the engine does not allow you to mix C++ and blueprint children of data assets, you are unfortunately forced to create C++ children.","I suggest installing the plugin directly to your project, and then creating new children inside the Items folder, which is found inside the plugins Core folder.","If you are creating a new category, you will also want to find the EItemType enum inside IFP_CoreData.h and create a new entry. Then inside your newly created .cpp file, override the constructor and set the type to be equal to this new category. This is so functions inside of DA_CoreItem can perform the correct casts to retrieve data from its children. You can find examples of this inside of the children of DA_CoreItem that come with the plugin."]}],[{"l":"Drag and drop","p":["A lot of the information PerformDrop function needs to do its calculations and logic should be stored in W_Drag. This is because setting and resetting all that information for all the tiles to optimize memory is simply just so much hassle compared to just putting your stuff in the drag widget, which is always just 1 of so it’s always optimized for memory and no hassle in managing it."]}],[{"l":"External Objects","p":["Both the item struct and container struct has an array of ExternalObjects. There are helper functions for both adding and removing widgets from this array.","What this array allows you to do is have other widgets receive the same update events from the I_ExternalObjects interface that the item widget and container widget receive without using delegates, which listen to ALL events, where as these events are item and container specific. This can be used for hotbars, ammo counters, quest trackers and more where a specific item needs to be monitored. The example project uses the tooltip widget as an external object, where it is listening to the override settings getting updated so it can update in real time alongside the item widget.","For your external widgets to receive these updates, you'll want to go to your class settings (1) and implement the I_ExternalObjects interface (2). You'll then see a IFP|External Objects category with all the update events. Some of these are limited to just items or containers and some are sent to both.","The I_ExternalObjects interface is designed to be extended for your needs.","Utilizing external widgets can replace delegate events from the component, but there are still moments where delegates are better, for example a quest tracker keeping track of how much of a specific item data asset you have in your inventory."]},{"l":"Adding custom events","p":["The good news is, you don't even need to modify the I_ExternalObjects interface class. Just simply make some interface, create your function and use the GetObjectsForItemBroadcast to get all the objects that want to listen to the event"]}],[{"l":"Modifying critical files","p":["Modifying critical files has its pro's and con's. Removing data is not recommended unless you are ready to fix any problems it might cause. Adding data should not be a problem, but there are some important things you must keep in mind. If your project is single-player only, adding data is a lot safer as there's no network bandwidth you need to manage and no replication you need to manage.","This page covers what is safe, dangerous or optimizations you can perform to critical files this system relies on."]},{"l":"DA_CoreItem","p":["This file is very safe to modify and is intended to be modified. Though it is recommended to make children for each type of item you will have (Weapons, consumables, armor, etc). Though there are several functions you might have to update if you remove any variables or functions. Remember to use soft references as often as possible.","In the base plugin there are a lot of children of this class as examples. All of which are safe to remove if some don't fit your project, though I recommend giving them a quick look-over to explore what differences were made to them."]},{"l":"FS_InventoryItem","p":["This struct will eat up most of your network bandwidth, so adding anything to it can be dangerous. Anything being removed from this struct will might require a decent amount of reworking some functions."]},{"l":"FS_ContainerSettings","p":["It is not recommended to remove anything unless you are certain you won't need it. Most of the data, other than the tile map, is extremely small. This struct does contain some small features, like TileTag's, not all projects need this feature, so it can be safely removed."]}],[{"l":"Objects and Drivers","p":["Item drivers should be destroyed after their logic is complete, especially if it’s from a stackable item. The reason being that it’s really hard or almost impossible to keep track of the stack it came from as that stack can be put into other stacks, split or fully used.","You must always keep in mind if the item driver is running logic that’s on a timer, you need to be aware that the item the driver belongs to might become invalid at any point. There is always the chance the item that owns the driver might get destroyed during the timer logic. I also recommend “locking” the player from interacting with the item during this timer or having some sort of failsafe if the player manipulates the item in some way while the timer is still running (For example; a gun playing its pickup animation and the player drops it mid-animation)"]}],[{"l":"Optimizations","p":["While IFP is already extremely optimized, there's a few things you can do and keep in mind to make sure you are getting the absolute most out of IFP.","To start, lets first cover what are the most expensive parts of IFP(Listed in semi-random pattern. It is not possible to 100% be certain what is the MOST expensive in all projects as there are multiple factors as when some things might become more expensive than others):","The biggest performance culprit are the item widgets. About 33% of the cost of making a widget for an item just goes into creating the UMG hierarchy inside the widget.","Finding an available tile during StartComponent. The more tiles an item occupies, the more calculations are required to find a spot. This is also where the InventoryHelper can improve performance. If a specific tile is provided to an item, it doesn't have to scan the entire container to find a free tile.","Disabling rotation for items through AC_Inventory-> CanItemBeRotated will reduce the amount of calculations required during StartComponent.","Unfortunately, removing some Blueprint features greatly improves performance. Let's take CheckCompatibility as an example. In a test with 100, this function in total took 1.5ms, but removing the BlueprintNativeEvent keyword from the UFUNCTION, which is the keyword that allows the function to be overriden at a Blueprint level, reduced the total time down to 0.090ms. Removing Blueprint support improved the performance by about 16 times. The same can be done to GetFirstAvailableTile, which will gain you the most performance gains."]},{"l":"Separating lag spikes","p":["One of the great benefits of IFP's structure is that it doesn't require widgets to function. Which means we can separate the lag spike of starting the component, creating the inventory, the widgets, and adding the inventory screen to the viewport into four chunks.","Calling StartComponent.","Creating the inventory screen widget.","Binding the containers with the widgets inside of the inventory screen.","Adding the inventory screen widget to the viewport.","Doing all of these at the same time will in some scenarios create a spike that is noticable to players. But separating them will make it (hopefully) invisible to players."]},{"l":"Widgets","p":["The tile widget is already highly optimized. The hierarchy can be reduced to just an image. (The demo widget has an overlay inside of it for debugging assistance. Removing it will almost double the construction speed.","The only feature in the tile widget that is expensive is the TileTags feature. It's not that the functionality behind it is expensive, it's simply the fact that this feature is getting executed per tile and containers can end up being 100+ tiles and the price starts to pile up, which is something you need to keep in mind in general when working with tiles. All your code must be highly optimized when it comes to the tile widget as your code might be spammed by hundreds of tiles within one frame.","The item widget will be going under a few optimizations throughout the next updates, but there are some core optimizations you can do:","Generated item icons are and always will be much more expensive than just disabling it and using a texture. The ItemEditor tool can take the generated item icons and save them to disk as a texture to assign in the data asset. Getting the best of both worlds, though this will remove any features where the icon updates depending on what is attached to an item, for example attaching a silencer on a gun and having the icon update accordingly.","Staggering out the generated item icons. This is actually a default feature that can easily be enabled in WBP_InventoryItem.","Depending on the simplicity of your equipment, you might want to do what some of the Resident Evil games do. They have a texture for each gun and every combination of it with attachments. Of course, they had very few weapons and very few combinations of equipments.","Create some of the widget components during runtime. For example, the ItemCount text. If the majority of your items can't be stacked, you are then creating a text widget that will never be shown for a lot of items. By default, IFP does not do this as this is generally a more annoying workflow. This really comes down to per projects needs."]},{"l":"Networking","p":["The only real meaningful thing you can do about network performance is trimming down the FS_ContainerSettings and FS_InventoryItem struct. For example; if you don't need the overwrite settings for items, you can remove it to reduce the RPC size of all items."]},{"l":"Equipment","p":["Do not use Blueprint Actors for your equipment. They are in some cases 11 times more expensive than skeletal/static meshes. Many people have proven that it is possible to do complex logic, like guns with animations and so forth without using Actor equipments. I personally suggest using GAS and whenever an item is equipped/unequipped, you fetch the mesh and let the GAS ability animate it and so forth.","Equipment easily take up 70%+ of the lag spike caused by StartComponent. If you want to keep using lots of equipment, you need to start calling StartComponent during your loading screens or managing equipment better. In reality, only the player character should be spawning equipment meshes."]},{"i":"color-sheet","l":"Color Sheet:","p":["functions- variable- category- class"]}],[{"l":"Saving and loading","p":["The demo includes an extremely basic save and load system. I will not be implementing anything advanced, because if you ever decide to remove the inventory system from your project, you will have to extract the save and load system from this project. You should have some system which you can bring to all of your projects.","Everything is saved in structs, so it should be compatible with your save system. It’s up to your save and load system to manage this, but if you need an example, the demo project has an example of a simple save and load system.","But let’s be honest, Unreal Engine’s blueprint save system is not very good and lacks too many fundamental features. I recommend a plugin from the marketplace called Saviour.","If you are going to make your own save and load system, I suggest using C++ as the current Blueprint functionality of Unreal's save and load system is really bad. There are a few C++ saving and loading system tutorials on Youtube which cover how to serialize nearly any data you want, all of which should be compatible with this system."]},{"l":"Things to keep in mind","p":["UniqueID's must reset whenever you try to save containers and items. The parent component object reference can not be saved. The component has a function called GetContainersForSaveState which provides you with a copy of the containers, but some data has been modified to be compatible with save files. I recommend looking inside this function to better understand what can not be stored in the save file."]},{"l":"Multiplayer","p":["When a client connects, it's up to your save system to assign them the appropriate container settings."]},{"l":"Equipment","p":["When you load a save, you might want some equipment the player has to become visible. You have two options:","The component has a delegate for when it is started, from which you can assign a Trigger Filter inside of the Equipment Item Driver. These should be instantaneous attachments and no animations should occur at the same time as they can cancel each other before any critical notifies occur.","Your save and load system has the ability to restore actors. From here you must ensure the restored actor gets the owning items UniqueID as a tag, unless you've also implemented a way to save the owning items UniqueID."]}],[{"l":"Setting up vendors","p":["To have a inventory component be set to vendor, you will want to go into the component settings and set InventoryType to Vendor.","Right now, the system only considers items that are children of IDA_Currency.h as viable currencies that can be exchanged for a vendor item. Prices are calculated inside FL_InventoryFramework.h-> GetItemPrice, and the function that evaluates if a player can afford an item is AC_Inventory.h-> CanAffordItem. Remember, you can override an items price inside their override settings.","The system by default has an array of currencies which players can use to buy items, but it does not by default provide a way of allowing the player to select which currency to use to buy or sell an item. It simply uses the first available currency it can find. It's up to you to implement that sort of logic.","Most games tend to have vendors keep track of how much money the vendor has, then when you sell an item to the vendor they spend their own currency and grant it to the player. There are three vendors in the demo, each showing a different way of handling the vendor logic.","If a logic error occurs, for example trying to give the player currency, but they do not have enough space in their inventory, you can call a delegate called CurrencyAdditionFailed. This is where you might want to implement some sort of mail system or queue system, as it feels pretty bad for players when they sell an item and they don't get their currency for it. The demo does not include any system for handling this problem.","There are many ways of handling vendor behaviour. Nearly every game handles it slightly differently, which is why the framework does not try to handle any of this logic for you at a C++ level.","Instead, there are three points in the system where you can inject your own custom logic and rules for handling vendor interactions.","The function AC_Inventory.h-> CanAffordItem will call a interface function I_Inventory.h-> MeetsCurrencyCheck, this simply asks the owner of the component what they value the item as.","You can make a child of BP_AC_Inventory and override the CanAffordItem function to implement your own custom logic.","The buyer and seller will receive a delegate on both the server and client either after or before the transaction, the notify is handled inside of WBP_Tile-> PerformDrop-> MoveItem. The delegate is where you would perform any currency exchange, and since the vendor belongs to the server, it's allowed to call TryAddNewItem if you want to give either the vendor or player currency after the transaction."]},{"l":"Using the crafting system as a vendor","p":["A fascinating trick some people have done is using the crafting system as a \"vendor\". Technically, this is more performant and could potentially be easier to manage. But the vendor will not have a grid of any sorts and will require you to setup most of the logic.","This simply revolves around creating the illusion to the player that they are \"buying\" items, where in reality they are crafting them and using currency as the crafting ingredient."]}],[{"l":"Sorting items","p":["There are a few ways to sort items, the primary way people will want to sort items is to also move items. Sorting an items array by itself is very simple, the item library editor tool shows an example of how to sort items alphabetically, but things become slighlty more complicated when you also want to move items inside of a container."]},{"l":"Adding sorting options","p":["I've designed the function SortAndMoveItem to only require one change for any custom sorting you want to perform.","In Async_InventoryFunctions.h there is an enum called ESortingType. You will want to add an option in there (I suggest adding your options to the end, the editor does not like it when you re-order or insert enum entries).","I suggest making your own IFP function library or making a IFP section in any of your existing function libraries. This is so if you ever update the plugin, any changes you make to the IFP function library won't be wiped. Then make a function that sorts an array of items. An example can be found in FL_InventoryFramework.h -> SortItemStructsAlphabetically","Go into AC_Inventory -> Internal_SortAndMoveItems and you'll find a SortType switch statement. You'll want to add your new sort option enum in there and call the sort function you just made."]}],[{"l":"Tag system","p":["Gameplay tags are extremely powerful and this system attempts to allow itself to expand to various needs using not just gameplay tags, but also a value associated with tags.","There are two systems, a regular gameplay tag and the second being a tag value system. Containers and items can have both. These tags can be updated, removed and added during runtime and are fully replicated.","For example; The system does not by default have a durability system. But with the tag value system, you can add a tag Item.Stat.Durability and give it a value, and voila! You now have a durability system! (Of course you have to implement the background logic that would reduce or increase this value).","The tag system is fairly simple, containers could use them as labels, for example Container.Type.Fridge and now any food items could have a tag value such as Item.Food.Quality which would slowly go down over time, but while in a container with a Container.Type.Fridge tag, it would decay much slower.","There are helper functions for resolving the value of specific tags, finding items or containers with specific tags and more.","Since these tags and values live on the container and item struct, it is very simple to serialize for your save file.","The add, remove and set functions have the option to \"IgnoreNetworkQueue\", if this is check to true, the item will not be added or removed from the network queue. This can be useful for moments where you are fine with server and client data not being in sync for a short moment. If you check this to true, you should NOT rely on that tag for any data validation."]},{"l":"Tag Value calculation","p":["The Setter functions have a class parameter, which allows you to inject your own calculations before the final value is set. This is a prime location for clamping certain values, such a durability value. You might have a CurrentDurability tag value and a MaxDurability tag value, then whenever you modify CurrentDurability, you can pass in a tag value calculation class that will handle the clamping for you."]}],[{"l":"Tile Tags","p":["The tile tag system is a simple way of adding tags to specific tiles inside of a container. In the base plugin, this system doesn't do much of anything, only being used to hide specific tiles to create custom shaped containers.","Tags can be added and removed with the AddTagsToTile and RemoveTagsFromTile during runtime or edited in the details panel while in the editor.","Adding and removing tags will call two delegates:","AC_Inventory-> TileTagsAdded","AC_Inventory-> TileTagsRemoved","Binding to these two delegates will let your code respond to any tag updates. An example can be found in WBP_DemoTile-> Construct"]},{"l":"Networking","p":["Even though the TileTag system is automatically replicated and can be modified during runtime, it is not recommended to overuse it for multiplayer games. This system can start eating up a lot of bandwidth very quickly, but this of course depends on the scope of your game."]},{"l":"Use case","p":["Like mentioned above, this is primarily used to create custom shaped containers by hiding specific tiles. But this has more use cases that some people have used it for:","Locking tiles and unlocking them based on some in game reward or event.","Empowering items that are in \"empowered\" tiles.","Items durability slowly improving while in a specific tile.","Some have even used the size of an item as a trade-off. Larger items would take more space, leaving the player with less space to carry other items, but the larger items could then occupy more of these beneficial tiles and gain these positive perks."]}],[{"l":"Crafting","p":["The inventory system does come with an optional module for crafting.","The crafting is a completely independent system and the inventory system has no reliance on it. Removing it will have no impact on the inventory system as this is a one-way relationship. The crafting system relies on the inventory, the inventory does not rely on the crafting system."]},{"l":"Classes","p":["Most classes can be created by right clicking the content browser and going into InventoryFrameworkPlugin -> Crafting, the entire crafting system revolves around two classes:","AC_Crafting: The actor component that handles the crafting and replication. It also stores all recipe's a player owns.","DA_CoreCraftingRecipe: The core crafting recipe data asset, these are your definitions for a recipe. This asset uses four different classes to create the recipe:","Recipe Requirements: All must return true for the recipe to be craftable. This is only asked on clients to enable the interaction of some widgets, but then asked again on the server when starting the craft.","Display Requirement: All must return true for the recipe to be visible when opening the crafting screen.","Craft Events: Code that is ran when a craft is successful, such as playing a sound effect or granting a crafting skill experience.","Recipe Data: This is ambiguous data meant mostly for blueprint programmers who don't want to modify or create custom children of the data asset. This allows you to add any data to a recipe, such as \"Time to Craft\" or a description to display in the UI.","The plugin itself does NOT come with any widgets to use the system. Only the example project has widgets. These are not needed, they are simply an example of how I would use the component and data asset."]},{"l":"Recipe handling","p":["Many games have recipes bound to things such as a \"crafting bench\", which is completely natural. The pain points come when you are deciding where you want to store recipe's and finding out what recipe's the player can and cannot craft.","When a player unlocks a recipe, even if it is tied to a unique object such as a crafting bench or area, the player still holds onto the recipe. This is so it is much easier to evaluate how far the player is into the game and evaluating whether or not you should grant the player a recipe as the other object might not be loaded. In general, it is much simpler and efficient to just have the player hold a reference to all recipe's they have unlocked, then either blocking the craft or preventing it from being displayed (or both) through other means, such as applying a tag on the player when they are near a bench and the recipe requires that tag to be displayed."]},{"l":"Serialization","p":["To save the players recipe's, the crafting component has an array of \"Recipes\" which you will want to save and then restore when loading a save."]},{"l":"Removing the crafting system","p":["To remove the crafting system from the plugin, follow these steps:","Remove all references in your project from any of the crafting system. (If you have just installed the plugin and aren't building on top of the example project, you can skip this step) If you are building on top of the example project, you'll want to remove the crafting component from BP_PlayerCharacter. Then go into WBP_Inventory and remove all the crafting widgets and remove the crafting sub graph.","Go into the plugin folder and into Content and delete the Crafting folder.","Go into the plugin folder and into Source and delete the IFP_Crafting and IFP_Crafting_Editor folders."]}],[{"l":"Tools","p":["All editor utility widgets are stored inside Plugin folder -> Content -> Core -> Widgets -> EditorUtilityWidgets -> Tools. Any widgets or special components for each editor utility widget is stored in its own folder named after the editor utility widget inside the EditorUtilityWidgets folder. This is done so you can bookmark/favourite the Tools folder and have access to all the tools quickly. You can also find all your editor utility widgets at the top of the editor -> Tools -> Tools, though there is no way to separate the inventory tools from your own editor utility widgets."]},{"l":"IMPORTANT","p":["All widgets, classes or files inside the EditorUtilityWidget folder is NOT designed to be used for a shipping product. If you wish to use anything inside this folder or any widgets used for these tools for your shipping product, you are responsible for ensuring it works properly.","Some tools have a TIPS AND TRICKS comment in their event graph."]}],[{"l":"Inventory Helper","p":["Video documentation","You will very likely be spending a good amount of time using this utility widget, so I suggest bookmarking it or having some way of quickly accessing it while you work.","Working with the raw container struct and the array of items is extremely cumbersome and not very efficient use of time. It also does not provide any sort of feedback of items that might be overlapping or have gone outside the bounds of the container.","This is why I've developed the Inventory Helper. This is a editor utility widget which attempts to mimick the final result you'd see in game and providing a place for you to create your own in-editor tools without going into C++.","It is HIGHLY advised to rarely, if ever, work with the raw container settings array. The only exception is class defaults. Use the inventory helper whenever you can.","Because of how many features this helper has, it becomes a lot to write down, so I've made a video (Not yet released) going over how to use the inventory helper and cover many of its features."]},{"l":"The void system","p":["What might confuse most is the \"Void\" widget and actor. Dragging and dropping an item onto the background will \"pin\" the item exactly where you dropped it. But the item data and its containers must be stored on an actor somewhere in the currently loaded level. The void actor is where that data is stored. This also has the benefit of acting as a proxy for moving an item from one actor to another. You can select one actor, move an item into the void area, then select another actor and move the item into one of its containers."]},{"l":"Limitations","p":["It is NOT recommended to edit the Container Settings through the SelectedComponent widget. The reason being is that the OnPropertyChanged event does not return which index has been modified. Meaning it is not possible to resolve which container or which item was modified, which means that every container widget and item widget must be updated. Only modify the container settings inside this widget if you really have to.","The normal highlight widget is not supported. An alternate method is used instead.","Item splitting is not supported.","Only basic item collision is supported, no combining or stacking.","The Item Void actor is not meant to be interacted with outside the inventory helper. If you wish to modify the Item Void regularily, consider modifying the InventoryHelper and have the tool modify it for you.","Generated item icons do not work. It is suggested to open your game, inspecting the item and saving the generated icon to disk, then setting it inside the data asset."]}],[{"l":"Item Editor","p":["The item editor is a simple, but powerful tool that allows you to select any item the asset manager can detect and directly edit the asset without opening a new window.","This tool is also meant to provide a simple interface for designers to create tools to help with their workflow. There are two tabs, the library and the editor. The library simply is where you can find all your assets and filter them. The second tab is your asset editor. At the bottom you'll find a toolbox. By default there aren't many tools in here, but it is meant for you to expand for your games needs."]},{"l":"Tool box","p":["With the asset comes a icon editor, a shape editor and a socket manager.","The icon editor allows you to edit the inspect and generated item icon settings, and allowing you to see how the item will look like in game with whatever item widget you have selected. You might want to go into WBP_ItemWidgetPreview and setting the default widget class to a class you commonly use.","The shape editor allows you to easily modify the DisabledTiles inside the IO_Shape object, if it has been added to the item.","Tip: You can click and drag to change the state of multiple tiles without having to click over and over again.","The socket manager lets you manage the sockets on the item if it has the IO_SocketManager object."]},{"l":"Tips and tricks","p":["You can resize the segments with the white bars.","If you click and drag the item asset icon into the viewport, you can place the item actor, just as if you were dragging the item actor from the content browser.","Right clicking the asset icon will open the item asset just as if you were to double click it in the content browser.","The top section of the library allows you to refresh the library, in case you create new assets while the editor is open. You can also scale the icons up with the slider. The final button will save the currently selected item asset."]}],[{"l":"Item Inspector","p":["WBP_Inspect has a ToggleDebug button on the top bar. Pressing this will expose this tool to the user.","There is a drop down menu allowing you to select whether you want to modify the generated icon settings or the inspection settings.","You can use this for figuring out what rotation and location you want to feed into the generated icon settings. Pressing any of the XYZ rotation or location buttons will rotate or move the mesh by the amount set in the slider. You can also manually put in a value in any of the text boxes. Zoom refers to the camera distance from the item.","You can save your values to the data asset by pressing the Save to Asset button. It is always more efficient for the game thread to NOT generate the item icons via the preview system. It is recommended whenever possible to save the icons and assigning that to the data asset, then disabling Use Generated Item Icon inside the data asset.","The engine does not load assets added to the content browser while a game session is active. For saved item icons to work properly, you must first right click and save the texture, then right click it and press Asset Actions -> Reload","The engine will not properly label the data asset as dirty (an asterisk * indicating that the asset has changes that need to be saved.) after pressing the Save to Asset Button or the Set Icon buttons. You must open the data asset yourself and press save, even though there is no star indicating that there are changes waiting to be saved. If you don't do this, your changes will be lost after closing the editor and it won't prompt you if you want to save the data asset."]}],[{"l":"Versions"},{"l":"Version system","p":["Versions are labeled like so: MajorIteration. MinorIteration. Patches","MajorIteration: New large features, small or large changes to existing files. Updating from one major iteration to another might break some things and downgrading might be difficult. These updates might change fundamental behavior.","MinorIterations: Adjustments to functions, optimizations, new tools or new small or medium sized features. These updates should not break anything, but might still cause initial compile errors.","Patches: Bug fixes, crash fixes, anything that is minor and shouldn't cause any compile errors, these are generally safe to update to."]}],[{"i":"281","l":"2.8.1","p":["Engine support: 5.4","The \"Need for Speed\" edition","This is one of the biggest updates since 2.0 and was on the border of becoming version 3.0. This update changes a good chunk of behaviour under the hood and brings lots of optimizations. IFP is already extremely fast and is probably the fastest and most feature-rich inventory system on the marketplace, but that doesn't mean there isn't room for improvements.","Highlights:","Added ItemStructObject's, which are a brand new way of handling gameplay logic for items. This is one of the biggest and most exciting features added to IFP since release.","Improved editor workflow.","Several performance improvements.","Updated documentation."]},{"l":"Items","p":["Added ItemStructObject's, which are a brand new way of handling gameplay logic for items. Documentation has been added","You can now drag the item data asset into the viewport to place the item actor. This is also possible by clicking and dragging the asset icon in the ItemEditor tool.","The VerifyData button has been removed. The logic has been moved into the IsDataValid function, which is ran whenever an asset is saved.","Added buttons for opening the item actor and item struct object.","Item assets thumbnails in the content browser and drop down windows now use their inventory image or the developer image as the thumbnail image.","Added ItemType tag to items to simplify the item type logic for items.","Shape is now baked into the data asset, greatly improving the performance of several functions that relied on the items shape.","GetItemDescription will now replace any text that includes \"< Tag value name >\" with the value of that tag value. For example; \"Current Durability: <IFP.Items.Stat.Durability>\" will be changed to Current Durability: 20\" if the tag value was 20. The apple, helmet and gun items uses this for an example. You can also style your floats with the new Rich Text Wrapper parameter. (Read code comment for more info)","Items can now have sockets, just like a static mesh or a skeletal mesh. This is achieved through the socket manager object on the item asset and can be edited through the ItemEditor toolbox."]},{"l":"Inventory","p":["When replicating containers to clients, server now clears the tile map when sending the RPC and has clients regenerate it when it reaches them, resulting in an average 20% smaller RPC sizes.","A new ID_Map system has been added. This allows the system to find ANY container or item in constant time, meaning it takes the same amount of time to find a container or item in index 0 as it takes to find a container or item at index 1000. This also means that GetItemByUniqueID has been reworked and is virtually free and this has had a tremendous performance improvement for projects with hundreds of containers or items in one inventory component.","A new IndexCoordinates system has been added, allowing the system to instantly convert a tile into an index. This wasn't expensive, but the system used this convertion so much, the small cost started to pile up.","GetFirstAvailableTile is no longer blueprint overridable.","The inventory component now has a custom icon.","Added GetItemCount function.","Added GetItemsByType function.","Added GetItemsParentContainer function.","Added a DoNotBind parameter to CreateAttachmentWidgetForItem so it's easier for people to do custom bindings."]},{"l":"Interfaces","p":["The I_WidgetUpdates interface has been renamed to I_ExternalObjects. The `ExternalWidgets system has also been reworked to not be limited to just widgets.","Many of the functions inside of I_WidgetUpdates have been reworked to expose more parameters and have better categories."]},{"l":"Tools","p":["The ItemEditor tool has had a layout make-over.","The ItemInspector tool has been disabled for runtime. Should only be used in the ItemEditor from now on."]},{"l":"Preview Actor","p":["The collider actor has been removed. This actor was a overkill solution to a rare bug. This has also improved the garbage collector performance.","Added a new option to skip the cloning process. If enabled, it'll just attach itself to the owner. This has almost doubled its performance.","All actors spawned by the preview actor now get labeled as one with the new I_Inventory-> SetIsPreviewActor function. You can then use the I_Inventory-> IsPreviewActor to find out if that actor instance is a part of the preview actor system or not.","Preview actor now supports leader poses. Documentation has been updated."]},{"l":"Documentation","p":["DA_CoreItem has been updated.","A new Optimizations page has been added."]},{"l":"Bugs","p":["Default items declared in the item data asset containers would fail to spawn.","Item struct in item data asset containers would say \"No Item Available\"","Widget factories were using the wrong blueprint type.","Crash if invalid data was passed into GetItemsTagValues","Generated item icons would go into the wrong folder.","Clicking on a specific spot on non-custom shaped items did not treat that spot as the anchor point."]},{"i":"281-1","l":"2.8.1","p":["Disabled struct object creation on preview actor instances.","Bug fixes:","Clients item data would not include the item struct object in some scenarios.","Moving an item via double click could cause item duplication.","Dropped items would not have their containers setup correctly, which would also cause those containers to get lost when picking up a dropped item.","The stack variables inside the data asset would get hidden if max stack was set to 1."]},{"i":"color-sheet","l":"Color Sheet:","p":["functions- variable- category- class"]}],[{"i":"271","l":"2.7.1","p":["Engine support: 5.3 and 5.4","This update might cause a few compile errors for those updating, the interaction interface has been split into two and some functions have been removed. Greatly simplifying the process of implementing a custom interaction system. On top of that, the tile and item widgets have been updated, drastically improving their performance."]},{"l":"Inventory","p":["GetFirstAvailableTile is now on average 6-12 times faster in large containers. This has significantly sped up item sorting and StartComponent in scenarios where containers have random tiles assigned to items, so for save files or items with assigned tiles, this won't have an impact.","Added TryAddNewItemByDataAsset function.","Added CheckForSpaceForShape function.","Added GetOwningItemForContainer function.","Added DoesContainerBelongToComponentOwner function."]},{"l":"Widgets","p":["W_Tile-> ParentContainer is now exposed on spawn. WBP_InventoryItem-> GetSize and GetDimensions have been deprecated.","A lot of performance improvements have been made:","WBP_DemoInventoryItem has been optimized. If no custom shape object is found, it'll just spawn one background tile and stretch it across the items size.","Drawing the custom shape for custom shaped grid items is now twice as fast.","The demo tile construction time has been reduced from 0.034ms on average to 0.013ms on average, drastically reducing the hitch from opening a very large container.","Several improvements to a handful of functions and widget hierarchies have been improved and drastically reduced the spike when opening the inventory for the first time.","The SizeBox requirement has been removed from W_Tile. Documentation has been updated.","Demo widgets have been updated to no longer use a SizeBox."]},{"l":"Interfaces","p":["BPI_Interaction has been split in two and some functions removed. Added new interface BPI_IFP_Helpers to simplify custom interaction system implementations. Documentation updated.","BPI_Interaction has been moved into the demo folder to help make it clear that it is an example interaction system."]},{"l":"Bugs","p":["Highlight widget was broken on Infinite grids","W_Tile was causing crashes in some scenarios","Moving an item as a client would cause the item widget variable to go null","Infinite grids wouldn't resize in some scenarios.","CanSwapLocations could cause a crash for clients and would give false positives in some scenarios.","IsTileValid would report false positives in some scenarios for infinite containers."]},{"i":"271-bug-fixes-54-only","l":"2.7.1 bug fixes (5.4 only)","p":["All of these fixes are very small and can easily be manually implemented. Reference the bug-fixes channel on the discord posts between 27th March - 15th April","GetItemDriver was not returning the correct driver.","TryAddNewItem Could fail in some scenarios.","The item data in the quick loot window could become stale in some scenarios, causing the MoveItem to fail.","Item icons could squish when re-opening the inventory.","When revealing hidden equipment, the equipment events were being called with the wrong data.","Splitting an item would cause the original item widget to behave as if it was item 0 in its container.","DataObject for drivers was not replicated."]},{"i":"color-sheet","l":"Color Sheet:","p":["functions- variable- category- class"]}],[{"i":"260","l":"2.6.0","p":["Engine support: 5.3","This update focuses on code quality, deprecating unused properties and general performance."]},{"l":"Inventory","p":["Data-Only container style has been added. This container style is highly optimized by not handling collision, dimensions, capacity or anything of the sort. Allowing you to handle the styling of containers purely through widgets, or create a optimized space for hosting item data that the player shouldn't see, such as a hidden wallet.","Example widget has been added ( WBP_DemoDataContainer and WBP_DemoTileDataContainer)","Added more helper functions:","IsSpacialContainer","IsSpacialStyle","DoesContainerSupportTileMap","FS_InventoryItem -> Item has been renamed to FS_InventoryItem -> ItemAsset","Added GetLocalInventoryComponent function to help those who want the inventory component to live on something other than the player pawn.","GeneratedItemIcons has been moved to the C++ component.","OldItemData has been removed from ItemEquipped delegate.","Added \"Type\" option for sorting items.","Containers TileTags can now be modified during runtime and replicate. Documentation added."]},{"l":"Widgets","p":["W_Tile-> ParentTile has been removed.","W_Tile-> OwningItem has been removed.","These two were forcing very heavy math and ForLoops, just to cache tiles that seemingly no one was using. As the codebase has improved, there are better ways of retrieving these values without caching them.","Deprecated W_Container-> Items","Added GetAllItemWidgets to replace deprecated variable."]},{"l":"Crafting","p":["Added GetRecipesRequiringItem async function.","Added GetRecipesForItem async function."]},{"l":"Bugs","p":["UniqueID was not being assigned in some scenarios in MoveItem.","InteractingWith was visible in the details panel for the inventory component.","The item count while inside the InventoryHelper would not display correctly when both values were set to the same amount.","the cpp file for A_ItemActor was not named correctly.","The InventoryHelper would treat the highlight in list containers as if it was a grid container, making moving items around difficult.","Items moved from a equipment container to a grid container would not have collision."]},{"i":"color-sheet","l":"Color Sheet:","p":["functions- variable- category- class"]}],[{"i":"251","l":"2.5.1","p":["Engine support: 5.3"]},{"l":"Inventory","p":["Sorting has been slightly reworked and is much more reliable. The Async function is no longer deprecated.","Added GetItemRef macro for blueprints.","Added GetItemsTags and GetItemsTagValues helper functions.","Added IsItemEquipped helper function.","The deprecated inventory component has been removed from BP_ItemActor.","MeetsCurrencyCheck now passes the buyer component, so designers can use external systems to use as currencies."]},{"l":"Widgets","p":["Added the option to disable dragging on item widgets.","Improved how container widget variable is set."]},{"l":"Equipment","p":["When an item is equipped, two interface events will be called on either the player or the spawned blueprint, depending on the settings. The equipment documentation page has been updated to include a new \"Events\" section."]},{"l":"Bugs","p":["Item widget would spam errors if a craft widget had to generate an item icon.","Dragging an item widget with no hosting container widget could crash the engine.","CheckCompatibility was not checking asset tags and tag values.","Data base search was not checking asset tags and tag values.","Looting a stackable item as a client could cause a crash.","The Preview Actor was not resetting master pose reference on skeletal meshes.","GetNearbyItemsDirectional was wrapping to the next line if the scan went to the border of a container.","GetFirstAvailableTile could return invalid rotation enum","Context menu was showing the Drop and Destroy option on items they did not have authority over.","Listen Server could no longer interact with chests.","ItemUnequipped delegate was firing off after the item had been removed from the inventory, leading to some functions not being usable after the delegate.","Moving items around in some orders could cause the incorrect item data to be removed."]},{"i":"color-sheet","l":"Color Sheet:","p":["functions- Variable- category- class"]}],[{"i":"240","l":"2.4.0","p":["Engine support: 5.3"]},{"l":"Example Project","p":["The UI styling has been reworked.","Added example for tracking tag values on equipped items, such as an armor stat."]},{"l":"Widgets","p":["Custom shaped items can now have padding and rounded corners. An object has been added that stores all the information for each item to save on performance.","Container widgets can now override their tiles default brush settings.","Added a GenerateItemIcon macro (Only available to widgets)"]},{"l":"Crafting","p":["A crafting system has been added. It is important to note that the crafting system has been designed to be 100% removable and the inventory system has zero reliance on it. If you do not want a crafting system and want to reduce the size of your packaged game and/or don't want to deal with the bloat, the system has been contained within a separate folder.","If you are updating your project and want to use the crafting system, you will want to go into your project settings -> Asset Manager and add a new index and set \"Primary Asset Type\" to \"CraftingRecipes\", set the asset base class to DA_CoreCraftingRecipe, then go into Directories and add all locations where you might store your recipe's.","Documentation for the crafting system","Added crafting category to the content browser context menu"]},{"l":"Bugs","p":["An item actor would not destroy itself if it had to stack with another item when looted through the quick loot options.","TryAddNewItem would not apply the correct rotation in some scenarios.","The ItemAdded delegate would not have the most up to date version of the item struct.","When dropping an item, you could get spammed with \"UObject is data-only. No item driver available.\"","GetItemDriver was using the wrong object class for its object paramater.","the SellItem function helper was not setup correctly, leading to clients not being able to use it.","Added a temporary solution to icon generation crashing the engine. If you are still crashing, you'll want to increase the delay inside WBP_InspectDebug"]}],[{"i":"230","l":"2.3.0","p":["Engine support: 5.3"]},{"l":"Quality of life","p":["External widgets for both items and containers are now TObjectPtr, which means it is not mandatory to remove the widget from the array for it to be garbage collected. But this does mean the widget must be referenced somewhere in your game, such as being on the screen. Otherwise, it'll get garbage collected.","Added a \"Inventory Framework\" category to the content browser right click menu, allowing you to quickly create assets.","Most of the classes for the context menu have a blueprint class parent, which is generally not safe to reference in C++. Because of this, a \"Inventory Framework\" section has been added to Project Settings -> Plugins. This also means you can easily change what classes the content menu creates without touching C++."]},{"l":"Inventory","p":["Added GetTotalValueOfTag function.","Added GetNearbyItemsDirectional function.","Added GetAvailableEquipmentContainers function.","Added GetCompatibleEquipContainersForItem function.","Added CanItemBeDestroyed function.","Added HasAnyItems function.","The item actor has been renamed to A_ItemActor/ BP_ItemActor"]},{"l":"Widgets","p":["The ContainerSettings variable inside W_Container has been renamed to TemporaryContainerSettings to reduce confusion around how to get the widgets true container settings.","OwningItem and ParentTile inside W_Tile have been deprecated. Use GetOwningItem to retrieve the item widget.","The quick loot window will now show the root item.","Quick loot window will now automatically hide and show the expand option if the item can be expanded.","Context menu has been reworked into an item object. If no context menu object is found, then it'll default back to the old method which I won't be maintaining and an print string will pop up.","The InventoryHelper no longer automatically imports the items default containers. It will now import them when the item is opened instead of overriding the default containers by default."]},{"l":"Bug fixes","p":["Highlight widget could go out of bounds.","TryAddNewItem was not calling the equip dispatcher if it added an item to an equipment container.","The drop option in the context menu would never show up for equippable items.","DriverStarted delegate was assigned to the wrong delegate.","Vendors would delete any currency items that didn't have an acceptable currency."]}],[{"i":"220","l":"2.2.0","p":["Engine support: 5.3"]},{"l":"Inventory","p":["Added tag values to component.","Security around TryAddNewItem has been loosened slightly to allow server RPC's to call the function for player controlled actors. Where as before the caller of the function had to be owned by the server.","The multithreaded SortAndMoveItems has been deprecated while a rework is explored.","SplitItem has been reworked slightly to fix some replication and collision issues."]},{"l":"Example Project","p":["Added an example of how to have equipped items attachment widget automatically get added to inventory screen."]},{"l":"Bug fixes","p":["An items default tags weren't being applied in the correct order inside StartComponent if the item didn't have the tag inside the struct, causing CheckCompatibility to always fail.","CheckCompatibility was not taking into account if the destination container belonged to an item it was containing, allowing two items to contain each other.","O_TagValueCalculation was not in the correct folder.","Custom shaped items where the top left index was hidden (Such as the gear item in the example project) would fail removing its own collision.","Internal_TryAddNewItem had incorrect object pointers, leading to some scenarios crashing the game.","ItemUnequipped would pass invalid item location, leading to difficulties managing and wiping the items data.","CheckAllRotationsForSpace would always start at rotation 0, which could cause issues for save files loading correctly.","MoveItem was not updating the item data it was using during its logic. So if the item count was updated while dragging an item, the function would undo the count update once it was dropped.","Internal_TryAddNewItem was not adding default tags and tag values to the created item."]}],[{"i":"210","l":"2.1.0","p":["Engine support: 5.2 and 5.3","This update focuses on improving developer tools, improving workflow, losening restrictions around item hierarchy and example project updates."]},{"l":"Item actor","p":["The hierarchy around A_ItemPhysicalRepresentation and BP_SM_ItemPhysical has been improved. The inventory component is now added in C++. This does mean BP_SM_ItemPhysical has 2 inventory components for this update. One is labelled deprecated, and you will have to start moving your component settings, such as the InventoryType, ContainerSettings and WidgetClass over to the new one. A button has been added to the actor which will copy over the settings from the deprecated component to the new one. These changes make the blueprint child much more optional and leaves only a few delegates you'll want to setup in any custom children.","Added StartInventoryOnBeginPlay variable as now the inventory component is started inside C++, this will let blueprint designers disable StartComponent on BeginPlay in case they want to customize when it's called.","RootItemID is now replicated."]},{"l":"Inventory component","p":["Added a tag system to the inventory component, though these tags are always replicated and use the default replication system, they do not use the custom replication system the other tag systems use.","Added a quick loot widget, which lets you preview items inside of a component before looting it or opening it, then letting you select and loot specific items without picking up the item or opening it.","Improved how containers are replicated and reduced RPC calls.","ItemMoved delegate has been update to provide both the old and new item data"]},{"l":"Tag system","p":["A new tag value calculation class has been added ( O_TagValueCalculation). These classes can be passed into SetTagValue for both items and containers and it'll allow you to have one place to adjust any values based on some relationship a tag might have with another tag. For example, a durability tag might need to be clamped to a max durability tag. Instead of pre-clamping SetTagValue parameter everywhere inside your code, you now have one spot to perform these adjustments. An example can be found in the example project inside Blueprints -> TagCalculations -> TVC_DurabilityCalculation"]},{"l":"Preview system","p":["Relative location and rotation for the camera has been reworked slightly to resolve some issues. The spring arm location is now applied to the scene capture component instead of the spring arm.","Saving an icon during runtime seems to no longer be supported in 5.2 by Epic, the button is now automatically removed while in-game. You can still save an icon inside the ItemEditor tool."]},{"l":"Editor tools","p":["General UI language has been updated and will continue being updated to feel more like it comes straight out of the box as a Unreal Engine tool, instead of looking like a custom tool with my own personal UI language.","Inspect debug widget has received a major revamp, is now more clear, less clutter, and less buggy.","You can now pan the preview actor around by using the right mouse button.","Item Widget preview has been updated to let you select a tile widget to use as a background and added controls to help with sizing the widget to accurate numbers instead of the scale slider.","The item editor's resizing for the filters and toolbox has been reworked to clear up a collision issue that was happening with sliders.","You can now shift + right click on a asset icon inside the asset library to open the items actor blueprint (If available)."]},{"l":"Equipment System","p":["Tags can be added and removed when driver starts, ends or on specific montage notifies. The example project uses this on the gun to enable/disable firing at specific points."]},{"l":"Bug fixes","p":["InventoryHelper would not scale correctly when the editor scaling was not set to 1","MoveItem could cause crashes in some scenarios where multiple clients were interacting with the same component.","CheckAllRotations was missing UFUNCTION specifier","Sorting items in a list container was not behaving correctly.","Items belonging to a vendor could be dropped without performing any transaction.","TagValueUpdated interface call was not working correctly.","Moving an item into an infinite container could break if the container had to expand to accommodate the item.","GetAllContainersAssociatedWithItem could break if an item contained another item that had a container."]}],[{"i":"201","l":"2.0.1","p":["Engine support: 5.2","Many files have received a large rework/updates and it's not possible to downgrade safely to 1.2. Remember to make backups of your project if you are updating from an older version.","Here is a list of files that have received major changes:","Blueprints:","BP_AC_Inventory","WBP_DemoInventoryItem","WBP_Drag","WBP_Highlight","EUW_InventoryHelper","WBP_ItemWidgetPreview","C++:","AC_Inventory","DA_CoreItem","FL_InventoryFramework"]},{"l":"Highlights","p":["Custom shaped items.","Rotations support for 180 and 270 degrees added.","QA validation system for data assets.","Increased focus on Objects for item data.","Improvements to how item and container widgets are referenced.","Mutlithreaded sorting function"]},{"l":"Items","p":["A validation system has been added to the data asset to help with QA.","Added AssetTags and AssetTagValues to the data asset. These are similar to the default tags, except they are NOT added to the item struct and can not be modified, removed or added during runtime.","Added GetNearbyItems function.","Attachment type This change has a host of benefits. It is one less reason to install locally, easier to expand, manage and more. This also has the benefit of allowing all of these to be easily overridable during runtime. This also means CompatibilitySettings and CheckCompatibility has been updated. CheckCompatibility will no longer check the deprecated enums to reduce confusion for new people.","Equipment slot","Equipment type","Helper functions for rotating and evaluating an items shape have been added.","Item rarity","Items can now be rotated 0, 90, 180 and 270 degrees.","Items now support custom shapes. This can be enabled by adding the \"Custom Shape\" object to an items data asset.","Price and Default Accepted Currencies moved to IO_Pricing","The first multithreaded sorting function has been added. For now I'm starting with just sorting by name to find out if the current approach works. If the current approach works, I'll start working on more sorting functions and hopefully make a tutorial on how to make your own custom sorting function.","The following enums have been deprecated and replaced with the items tags:","The following variables have been deprecated and replaced with objects:","The function CheckBothRotationsForSpace has been deprecated because the name does not make sense anymore. Has been replaced with CheckAllRotationsForSpace","This is achieved through a validation class (so you can write your validation at a blueprint level) and a interface function from I_Validation. The plugin comes with a basic example.","Weapon type","When an item is equipped and using a blueprint actor as it's physical representation, the root items UniqueID is now passed to the actor and stored inside RootItemID, allowing the spawned actor to access it's true item data."]},{"l":"Tag system","p":["Various functions have been added to validate if a tag and tag values can or can not be added, removed or set for both items and containers.","The Tag value struct now has a custom editor slate widget to make it easier to work with and take up less space.","Note: As of 5.2, there's a bug with some custom structs and editor utility widgets not displaying the custom struct correctly. To get around this, I've made it so it displays the default struct widget while inside a editor utility widget.","TileTags have been added for containers to replace HiddenSlots and LockedSlots, which are now deprecated. This is a prototype, it currently can not be modified during runtime for multiplayer and there are no events for when a tag is removed or added."]},{"l":"Widgets","p":["Both the drag and highlight widget have been updated to behave more intuitively with custom shaped items. This also means both have been reworked quite heavily. For non-grid containers, the behavior should remain the same as before.","The drag and drop operation no longer has a visual and WBP_Drag is now added to the screen (You might have to set the ZOrder). This is to resolve a interpoloation issue you could not control inside the drag and drop operation drag visual and improve the consistency of WBP_Drag.","Attachment widgets no longer need a reference to the parent items widget.","Attachment widgets now remove themselves correctly from the parent item when it is destroyed.","Both the item struct and container struct now reference the item widget and container widget respectively.","AC_Inventory-> ContainerWidgets has been deprecated as the container struct now references the container widgets. Added GetAllContainerWidgets and RemoveAllContainerWidgets to replace the array."]},{"l":"Objects and drivers","p":["Objects have had their hierarchy changed. There is now a \"pure\" ( O_PureItemObject) item object below the regular item object, which is now meant for data only objects. This is to optimize memory footprint as the framework becomes more focused on objects and for projects that are heavily utilizing the object system.","ConstructionMethod is getting deprecated. You should reparent your data-only objects to O_PureItemObject.","Objects can now prevent multiple copies of themselves inside an item assets ObjectsAndDrivers array. By default this is set to false, to change it you must override the AllowMultipleCopiesInDataAsset function.","Objects now get notified when they are added to the item assets array with AddedToItemAsset. Allowing for more complicated default variables.","Added object for pricing ( IO_Pricing)."]},{"l":"Tools","p":["A shape editor has been added to the ItemEditor's toolbox.","A conversion tool has been added to help convert the deprecated enums listed above into gameplay tags and move some deprecated variables into their new objects. This tool will be removed in 2.1 and is only meant to help those upgrading from 1.2 to 2.0.","Container handle bar context menu has been removed from the inventory helper."]},{"l":"Bug fixes","p":["When removing an item as listen server, it would attempt to remove the item twice.","Attachment widgets were not being removed correctly in some scenarios.","GetItemDriver was not returning client-only objects for single player sessions.","Skeletal mesh equipment animations could end up in an infinite loop if they contained a MontageNotify with the same name as their WaitForNotify.","Equipment system for clients would try to play an animation on skeletal meshes with WaitForNotify and then create it, causing the animation to not play as the mesh had not been replicated yet.","Updating the unequip location for static and skeletal meshes was not functioning correctly.","CheckCompatibility would not take the items default tags and tag values into consideration while in the editor.","Increase and Decrease item count could crash if invalid item data was passed in.","TryAddNewItem could cause issues with CheckCompatibility"]}],[{"i":"120","l":"1.2.0","p":["Engine support: 5.2"]},{"i":"important-for-those-updating","l":"Important for those updating:","p":["Because both the container struct and item struct were modified in this update, it means that a lot of blueprints were updated and might override any chances you might have made. Remember to backup your version before installing."]},{"l":"Component","p":["FindFirstAvailableContainerAndTile and FindFirstAvailableTile have been replaced with GetFirstAvailableContainerAndTile and GetFirstAvailableTile. These functions can now also be overriden at a blueprint level to allow designers to implement their own rules of how the system finds available containers and tiles.","CheckForSpace and CheckBothRotationsForSpace has been updated to return an array of items that were in the way instead of just the first item.","Added function for checking if items can be swapped and another function for swapping 2 item locations.","Added UpdateItemsOverrideSettings so override settings can be updated in a live multiplayer session. Another function called CanActorChangeItemOverrideSettings has been added and it will ask the server if an actor is allowed to modify an items override settings. By default, this is set to always return true. You can override this function at a blueprint level."]},{"l":"Items","p":["Default item tags have been implemented. These are defined in the item data asset, whenever a component is started and an item does not have any of the tags from the data asset, they will automatically be applied.","ContainerName has been labelled as deprecated and will be replaced with ContainerIdentifier tag, making it easier for renaming a container and reduces human error when binding containers with their widget representation.","During 1.2 both the ContainerName will continue to work for most functions, as most have been updated to use ContainerIdentifier instead, but ContainerName will be fully removed in the next update. It's recommended to update your containers immediately.","The physical actor for an item no longer requires any containers to be setup inside the blueprint. When the component is started, it'll automatically add the default containers from the data asset."]},{"l":"Item drivers","p":["Item drivers now have the option to \"follow\" the item they were created by. This means that if a driver is created for an item and the item is moved to a new actor, that driver is moved as well to the new actor. The driver is not destroyed and reconstructed, it will retain all information and continue running any timer logic.","Drivers are now referenced by the item struct, giving easy access to access an items item driver."]},{"l":"Widgets","p":["The update functions inside of W_InventoryItem have been labelled as deprecated.","New I_WidgetUpdates interface added, contains all the update functions that were deprecated in W_InventoryItem","During 1.2 both the deprecated functions and the interface events will be called, but the update functions inside of W_InventoryItem will be fully removed in the next update.","Item struct and container struct now has an array of \" External Widgets\", making it easier to manage hotbars, quest trackers and any other widget that is listening to any item updates without listening to a bunch of delegates. Documentation can be found here","External widgets get all the same Update functions that the item widget and container widget does from the I_WidgetUpdates interface.","More update functions have been added for tags, tag values and equip/unequip events.","Add, Remove and Get External Widgets helper functions for both items and containers have been added."]},{"l":"Example Project","p":["Added two quick slot example, one for global tracking where a specific item asset is tracked across the entire inventory, and another for a specific slot.","In the context menu, the Equip and Unequip buttons now actually... You know... Equips and unequips the item...","Example project has been updated to no longer use any of the deprecated features.","Gameplay tags have been moved to a data table.","The tooltip widget has been updated to use the external widget system to provide a simple example of the new external widget system.","Objects now have a better display name."]},{"l":"Bug fixes","p":["When splitting an item, the newly created item widget would get created in the incorrect location.","When trying to move an item on the same slot but with a new rotation, it would not update the rotation.","Generated item icon were being stretched in certain scenarios.","Item count was getting reset to default if it was dropped.","Random min/max count could be called multiple times.","The item and container tag delegates are no longer getting spammed.","GetItemDimensions could sometimes return wrong values","Set/Remove tag value and IncreaseItemCount wasn't using the new replication system."]}],[{"i":"111","l":"1.1.1","p":["Engine support: 5.1 and 5.2"]},{"l":"Improvements","p":["Preview actor now destroys its own collider actor when itself is destroyed.","Refreshing the preview actor is now faster.","General code cleanup and unused variables have been removed.","Items can now be labelled as \"new\". This label can be removed at any point. This can help players find out what is new in their inventory and they haven't interacted with yet.","Items that do not have their containers added to the ContainerSettings array will now retrieve their default containers from the data asset and add those to the component when it is started.","A tag system has been added, allowing you to add tags to items and containers, and also associated values to certain tags."]},{"l":"Tools","p":["New tool as been added, the ItemEditor.","Added function library for editor tools.","Common data base widget added so it is easy and fast to add your item data base to any editor tool.","It is now possible to generate item icons while in the editor.","Improved multiple widgets behavior and accessability while in the editor.","Added a tool for previewing how an item widget will appear in-game while in the editor."]},{"l":"Bug fixes","p":["Refreshing the preview actor no longer breaks on shipping build for some actors.","Preview actor no longer 1-frame snaps or resets visual effects when refreshed. It now resolves what components have and have not been duplicated and only updates those.","Fixed an issue where item rarity colors were not working while in the editor."]},{"i":"111-1","l":"1.1.1","p":["Note: This is 5.2 only. Apparently Epic decided after manually reviewing the 5.1 version within 7 minutes said \"There were no notable differences\" so they just won't accept it...","Autonomous Proxies on listen no longer is breaking replication.","When an item was dropped, the containers belonging to any children item were not being removed properly."]}],[{"i":"100","l":"1.0.0","p":["Engine support: 5.1","Official release"]}],[{"i":"faq","l":"F.A.Q"},{"i":"q-can-the-system-be-used-for-a-more-traditional-inventory-system-where-all-items-are-1x1","l":"Q: Can the system be used for a more traditional inventory system where all items are 1x1?","p":["A: Of course! Containers have styles, and the List style already converts all items into 1x1."]},{"i":"q-will-statsattributes-or-ability-systems-of-any-kind-be-added","l":"Q: Will stats/attributes or ability systems of any kind be added?","p":["A: No. I believe most people should be using the Gameplay Ability System framework as it is becoming the industry standard or something similar (I personally suggest GAS Companion from the marketplace). A lot of people also already have a stat/attribute or ability system in place and I do not want to step on their toes. The tag system does allow you to create basic stats and attributes for items, but I generally recommend people use GAS or a more fleshed out system designed around that."]},{"i":"q-will-i-be-adding-any-art-meshes-or-animations-to-the-asset","l":"Q: Will I be adding any art, meshes or animations to the asset?","p":["A: No, with the exception of some basic things like the Tile Icon and some other things, just enough so you don’t get any compile errors and can interact with the system before you implement your art."]},{"i":"q-does-the-plugin-feature-an-interaction-system","l":"Q: Does the plugin feature an interaction system?","p":["A: This plugin does not provide a fleshed-out interaction system for you, but an interface system is integrated in the demo's as that's the foundation of every interaction system I've seen. This is done so your project does not build a dependancy on my interaction system if you ever decide this plugin does not fit your project. The interaction system is designed to be replaced, as most people already have an interaction system already in place."]},{"i":"q-will-i-be-adding-x-featuresystem","l":"Q: Will I be adding X feature/system?","p":["A: Only if it’s a highly requested feature, only then will I either implement it into the base asset itself or advise you how to make it yourself. You can track what is being worked on and what will be worked on in the future by going to the Trello link at the top of the page."]}],[{"l":"Bugs","p":["This list is only relevant to the latest version of the plugin, old version of the plugin will slowly lose bug-tracking. If you are on a old version of the plugin and have found a bug, you can always ask on the discord for help."]},{"l":"Known Bugs","p":["The \"Reset to Default Property Value\" button for container settings is not resetting values to their proper defaults and it's always showing for all values, even if the value is set to its default. I am unsure what is causing this.","The drag widgets sizing is much larger than it is supposed to be for a couple of frames. There is currently a 0.05 delay inside WBP_Drag to resolve this. This is a band-aid fix, I'll try to resolve this fully in the future.","While inside a editor utility widget, the gameplay tags slate widget is not updating properly. The DetailsView widget is riddled with a few bugs as of at least 5.2 when it comes to custom slate struct widgets. The best you can do right now is open the gameplay tag to see what values are inside of it and adding/removing something to update it, then it'll show the values inside the tag correctly.","In 5.2, saving an icon has a chance of crashing the editor. This is happening because Epic modified how this is handled into an async task, but left no delegate for me to bind. For now, a delay is being used instead of a delegate, but on slower computers, the async task might not be finished by the time the delay finishes, causing a crash. If you are crashing, go into WBP_InspectDebug and click on B_SaveIcon and find its OnPressed event. You'll find a delay and you'll want to increase it.","The inventory component might be falsely reporting it might be \"corrupted\" or a custom property list is not initialized correctly. This is happening because when a component is declared in C++ and then the ComponentClass is set to a blueprint, it starts loading everything connected to that blueprint. Some assets seem to be breaking something inside of UE's loading process and causing issues. I haven't noticed any patterns, but most of the issues seem to occur when a player character is referenced. Because of this, you really have to mind your hard references, or go through the process of removing the C++ version, which I do not recommend. You should be minding your hard references, especially when it comes to the inventory component."]},{"l":"Common Problems","p":["These aren't bugs, but problems that can be misinterpreted as bugs.","The inspector debugger changes are being set but not being saved after closing the editor. This is because the engine seemingly refuses to label assets as dirty while a gameplay session is active and doesn't label them as dirty after closing the gameplay session. An asset that is dirty will have an asterisk (*) indicating that you have changes that need to be saved, but since it refuses to label it as dirty, it means that you have to manually open the asset and pressing save, even though there is no star indicating that you have changes that need to be saved. This may be a engine bug or is intended, but it seems that there's nothing I can do about this.","The WBP_Highlight widget and WBP_InventoryItem widget padding doesn't take into account any scaling their parent widgets have to do (like borders). So if you are getting issues with items being dropped in a different tile or an item not lining up properly, there is most likely an issue with your UMG hierarchy/scaling. You might have this problem with scroll bars most of the time. An easy fix for that is to go into the ScrollBox, go into Scrollbar Padding, let's say the scroll bar is on the right side, go into the right side padding and minus the thickness of the bar.","BP_PreviewActor's automated camera distance is determined by all components which have collision enabled. This means if you have collision hitboxes or something similar on your actors, the camera will try to adjust to fit that in the camera view. Remember to use the tag “ DONOTPREVIEW” on those collision components if the BP_PreviewActor is copying them.","Your item is not showing up in the asset manager or your getting a \"Ignoring PrimaryAssetType Items - Conflicts with SOMECLASSNAME - Asset: ITEMNAMEHERE\" in your message log. This happens when there are two identical data assets. This will most likely happen when you have two completely blank data assets.","The highlight widget is going outside the boundaries of the container or is getting clipped. This happens if the sizing of the widget does not match the container dimensions. This is most common if the container is slotted into a canvas panel. If that is the case, you can check \"Size To Content\". For other widgets, you will have to manage the sizing of the container and in some cases, it's handled automatically.","After adding or changing default values inside FS_InventoryItem, the InventoryHelper will falsely report a value is no longer set to default and will reset it to the wrong value when pressing the reset button. This is happening because the struct inside the InventoryHelper did not get updated. You must go into EUW_InventoryHelper and find SelectedItem and update its default settings. The same might happen to the context menu, so you must go to WBP_ContextMenu_EditorOnly and find Item and update its default settings."]}]]