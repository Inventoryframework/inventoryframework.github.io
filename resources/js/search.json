[[{"l":"Inventory Framework Plugin"},{"i":"last-updated-21st-december-2022","l":"Last updated: 21st December, 2022"},{"i":"what-is-the-inventory-framework-plugin","l":"What is the Inventory Framework Plugin?","p":["Nearly every inventory system shares the same foundation, a container with tiles and items slot into those tiles. This Inventory Framework Plugin (IFP) attempts to be that foundation for your project, while allowing for a high level of inventory design, item customization, rapid prototyping and system integration.","From my research, inventory systems were taking 2-6 months or more (depending on how advanced it was) to be designed, bug tested, network tested and to be documented. With this framework, I try to provide you the framework needed to create your perfect inventory system and bring that initial creation time down.","What this provides is the C++ foundation for your programmers and a good Blueprint foundation for your designers, which includes:","Actor component and item parents that handle all the logic for you and are abstract enough so you can implement your mechanics and systems into it.","Widgets that are designer friendly (Easy to implement new logic, add animations to events, create children, etc). They also handle all the drag, drop, highlighting, splitting, combining logic and more.","Data asset which only shows relevant information to your desired rules with inbuilt functions and instanced objects that can have custom variables per data asset.","A system that has no reliance on widgets to create or handle its data, meaning it is possible to use the data for any widget you create and not be dependent on the widgets that come with this system.","Container system that allows for near infinite (array limit) items inside of items. This means you can make a backpack, which has several containers, then a gun inside one of those containers and then that gun can have containers which have items inside of them. It can keep going for as long as you want.","Actor appearance duplication system that copies the appearance of your items allowing you to both inspect items and auto-generate icons. It works with all actors, not just item actors. No longer do you need to follow a hierarchy setup like many other inventory systems need. You can create your items however you want and the system will automatically duplicate the appearance for either generating item icons or letting you examine an item.","It is NOT an inventory to fully replicate the mechanics of any specific game. If you want your system to behave like a specific game, you will have to implement those specific mechanics yourself. This system does try to provide you with the functions and data to replicate most inventory systems.","This plugin does not provide an interaction system for you, but an interface system is integrated as that's the foundation of nearly every interaction system I've seen. This is done so it's more flexible to a project's interaction system. Some use on-click, some use linetrace or something else, but at the heart of most of them is an interface handling the interaction. This is designed to be replaced, as most people already have an interaction system already in place.","This plugin does not contain any game-ready art, only demo-ready art. This is purely an inventory system for you to integrate with your game. This is mainly done to reduce bloat and integration pains.","It is advised to have some C++ knowledge or have access to someone who has C++ knowledge before buying this plugin, but it is not necessary.","If you have any issues or questions neither the videos or documentation answer then feel free to message me on Discord or join the discord channel. You can look at the FAQ for more info."]},{"i":"color-sheet","l":"Color Sheet:","p":["functions- Variable- category- class"]}],[{"l":"Introduction","p":["This plugin was created for an open-world game that has very strict performance requirements. Because of this, some logic is handled in C++ as an inventory system like this does a lot of math. The design architecture is also designed to give programmers more control of when widgets and data is initialized. The architecture has also been made in mind for large-scale projects. This does mean though that there is a specific and strict workflow for setting up the component for items, especially sub containers. I've made an Editor Utility Widget which should prevent any human errors and allow people to work in the system without those strict requirements slowing down your creation process.","The architecture was made with designers in mind, so certain C++ functions can be overridden in Blueprints and some functions are only needed on the Blueprint level and in some cases there are both C++ and Blueprint versions of the same function. This system is not meant to be purely C++ or Blueprints, but a healthy mix of the two. If you can't write in C++ or don't have access to anyone who can write C++ code for you, the current functions should allow for you to create nearly any Blueprint logic you should need.","Data Assets are being used instead of Data Tables for a few reasons:","You can create children of the item data asset to create a brand new type of item with its own unique settings and not have those settings clutter the items that aren't relevant to those settings.","You can control their loading and unloading in the Asset Manager.","Easier to create Utility Widgets and automating tests.","It's easier to find out what assets are referencing which data asset, while with Data Tables, it can get messy to find out what asset is referencing a specific row.","Data tables are not ideal for managing massive databases. Anyone who has had to deal with source-control while working on an item will know the pains data tables can bring for a system like this.","For more advanced users, it’s possible to add slate widgets into the data asset editor window. For example, a recoil pattern editor for gun items.","The only con regarding data assets is you don’t get a nice table view like you get with data tables. But you can use the matrix editor which gives you a similar editor to the data tables and is in some ways even more powerful.","Native Controller support is not yet added but is planned.","Split screen support is not something I will be adding.","The plugin was designed to be installed locally to your project, not the engine. With how the marketplace works and how the engine works, it was much simpler to make this asset a plugin.","Many things have been designed to be as abstract as possible and assume as little as possible about YOUR project and creation process. I do not want to dictate any creative vision and I do not want to step on any toes. I’ve tried to keep the system as painless as possible for you to integrate YOUR systems and assets with this inventory system, such as an attribute, ability or crafting system."]}],[{"l":"Installing the plugin","p":["Because of how integral an inventory system is to a game, I highly recommend you DO NOT install the plugin to the engine and then use it that way, but instead install the plugin locally to your project. That way you can use the plugin in multiple projects without having a change that works in one project mess up the other project. This means you can also have much better control how the parents behave and work and not have to worry about changes made for another project. But it does mean updating the system is a bit harder than usual. I’ll try my best to keep the change log as up to date and accurate as possible. I also recommend using some form of Source Control for easier updating.","This does NOT cover how to install an IDE such as Rider or Visual Studio. You should already have an IDE installed. There are also a few demo files that you’ll want to replace and enum entries you need to rename to fit your project. Unreal's docs for setting up Visual Studio","If your project doesn’t have any C++ code, you will want to go into the engine and at the top go to Tools -> New C++ Class. It doesn’t matter what you create here or where you save it. This is just to get the engine to generate all the files you need to compile the plugin.","Go to your Unreal Engine installation -> Engine -> Plugins -> Marketplace and copy the InventoryFrameworkPlugin.","Go into your project's root folder (Where your .uproject is), create a folder called “Plugins” if you don’t have one.","Paste the InventoryFrameworkPlugin into the plugin folder.","Go back to your .uproject, right click and generate “Visual Studio Project Files”.","Open the solution file with whatever IDE you use (For example Visual Studio or Rider) and build the project.","(Optional) You can now uninstall the plugin from the engine through the Epic Games Launcher, though you won't get notifications from the Epic Games client whenever an update is available.","Everything in the demo folder is designed to be replaced by your assets/Blueprints. It is only there so you don’t get any errors on startup."]}],[{"l":"Adding the component and containers","p":["Under revision","There are two components, one is the C++ parent and the other is the blueprint child of the C++ component. There is nothing stopping you from making your own BP component with the C++ component as its parent but I still recommend using the Blueprint component. You can also make a blueprint child of the blueprint component, which is the recommended path if you are going to override any functions. You want to add it to your actor, if you're making an item, I suggest using BP_SM_PhysicalItem as its parent and the component will automatically get added.","Bind the containers to your widget. Go into your widget and add WBP_Container or any children of that widget to your layout. Then go into your graph and implement the I_Inventory interface. Find the GetContainers interface function and make an array and add your containers. This order is important as the component often searches for things beginning at index 0, so your most used containers should go first to optimize speed."]}],[{"l":"Activating the component","p":["Under revision"]}],[{"l":"Equipping and unequipping items","p":["A big problem I try to solve with this system is that I did not want to assume anything about how your actors' meshes are set up, how your equipment setup looked like and I did not want to make a base player or actor blueprint. There are two main reasons behind this decision: First is this allows you complete control over what items are attached to (for example if you have a horse and want to give it armor, but the component is only setup on the player) and secondly is that people might already have a player blueprint hierarchy setup and I did not want to mess with that and some people might not want to use my hierarchy setup.","Your container's compatibility settings dictate what is allowed in them. If you only want helmets to go into container X, then your helmet items should use EquipmentSlot(Rename one of the options to Helmet) and your container should only allow Helmets. You can also of course rename one of the EquipmentType enum entries to “Head” and make your helmet item be of EquipmentType“Head” and then all items that might not be a helmet, but are a head item like glasses can go into that container.","EquipmentData in your item data asset is a struct which attempts to solve most issues when it comes to having multiple skeletons, meshes or complex equipment logic, such as having a gun attached to a backpack which is attached to the player character and that gun has a sight attached to it or FPS shooter setups where you have a local arms skeleton and then a full body skeleton. This struct also attempts to keep the system away from hard coding any types of “main weapon” and “secondary weapon” or anything of the sort. I’ve found those types of setups often become cumbersome when a designer wants to add or remove these types of things.","During my research, I found an astonishing amount of different workflows and processes. It was very daunting to try and solve all of them in one go, and maybe my system isn’t perfect, but it tries to solve as many as possible at once, while still being flexible and adjustable.","I recommend reading the comments in the EquipmentData struct (Found in DA_CoreItem.h) and going through OT_Equipment(which is an object template found in the plugins folder Core -> ActorParents -> ObjectTemplates.) and look at the logic in there to get a better understanding of how the system is using this struct. I would explain it here, but it’s so long and extensive that explaining it in just text and pictures would take too long.","This object attempts to copy the system that is used in GAS with its PlayMontageAndWait function, which creates an instance that handles the animation, but I wanted to keep mine inside of Blueprints."]}],[{"i":"how-does-the-component-work","l":"How does the component work?","p":["With how strict the performance requirements were for this plugin, I’ve had to design this inventory system slightly differently from other systems you might find either on the marketplace or Youtube tutorials. The biggest thing to keep in mind is that this system does NOT rely on widgets being valid or created to keep track of its data.","This is to achieve four things:","This greatly speeds up widget construction since all the data they need (for example where an item is inside the container and so forth) is already prepped.","Allows you to remove widgets from RAM and still have the necessary data to find out important things like looting an item and finding a free space for that item.","Since widgets have way fewer references, there is less work to be done to manage widgets getting garbage collected properly.","Designers are able to create new widgets and prototype much faster since all the data they need about containers and items is always available from the component.","ContainerSettings is an array of all the settings your designers will use and some settings only the programmers will use, and with all the settings combined you can figure out everything about that container. When creating a widget for a container, the widget uses a UniqueID to find out what container it is representing. Items differentiate themselves from each other by using a UniqueID as items can have the same name, same data asset and so forth. A component can not give items or containers the same UniqueID twice. This is essential for functions to work properly. The component is designed to live on individual actors, not the player controller."]}],[{"i":"how-does-the-networking-work","l":"How does the networking work?","p":["Certain inventory data can become quite large, especially with how many containers and items you allow in an inventory. To optimize, we try to simplify things. Players only receive data from components that they request data from and data from their own components, but also any update from components they are currently interacting with.","The component keeps track of the players that are currently interacting with a component with the Listeners array, then whenever PlayerA moves, adds, removes or interacts with an item in some way, the component sends RPC calls to the other \"listeners\" so their widgets and data get updated.","For functions that modifies a components data, such as moving an item or modifying an items stack count or modifying any other data, you must remember that clients only have authority over their own component, they do not have authority over other components data. This is simply how networking in Unreal Engine works. Because of this, most functions require you to call the function on the component the client has authority over. Even though the item you are trying to modify is not on that component. This is why, when you look at some of the source code, the functions are getting the component the item belongs to through its UniqueID. ParentComponent and modifying that component's data through the component the client has authority over.","For most functions that modify data in some way, only a single version of that function is available for you to call, and that function handles the replication for you. This is to simplify the amount of functions exposed as it can get very daunting to try and handle every replication scenario and making sure your calling the right function. If you wish to modify how the replication is handled, you can always go into the functions, modify them, or enable the server/client/internal functions to be BlueprintCallable."]}],[{"l":"Naming format and versioning"},{"l":"Naming format"},{"l":"Functions","p":["Networking functions are prefixed with C_ for client, S_ for server and MC_ for multicast.","In blueprint functions, local variables are prefixed with an L"]}],[{"l":"Classes and Settings","p":["For all the classes that have a blueprint child, it is advised to use the blueprint as your parent for your classes, but is not mandatory The blueprints have been designed to have children with your own custom logic and design.","All base classes will have a link to their documentation (if available) at the top of their header file or in the Event Graph."]}],[{"l":"A_ItemPhysicalRepresentation","p":["File location: InventoryFrameworkPlugin\\Public\\Core\\Actors\\Parents\\A_ItemPhysicalRepresentation.h File location: InventoryFrameworkPlugin\\Private\\Core\\Actors\\Parents\\A_ItemPhysicalRepresentation.cpp","File location: Content\\Core\\ActorParents\\BP_SM_ItemPhysical.uasset","This is your physical representation of the item. If you already have items/weapons of any sorts, you will want to reparent those classes to this.","This is not supposed to run important logic as these can get destroyed and created by the user. (for example equipping and unequipping)","In your data asset, you can access this class so whenever you drop the item out of the inventory or want to spawn it in some way, here is how you access the original pickup class.","It’s very important when making your items that have a physical representation in the world and can be picked up that the component on that actor references the data asset that references this physical actor. Otherwise when you drop the item, it’ll spawn the wrong class.","The setup for pickups goes like this: In your ContainerSettings index 0, you set ContainerType to CurrentItem and item index 0 is the pickup data asset. There should be no other items in this items array. Containers that might be attached to the pickup are added after and they can have Inventory or Equipment selected, but never CurrentItem.","There is a tool included in the plugin that queries every item data asset, checks the actor references and then checks if that actor reference is referencing the correct item data asset."]}],[{"l":"AC_Inventory","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Components\\AC_Inventory.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Components\\AC_Inventory.cpp","File Location: Content\\Core\\Components\\BP_AC_Inventory.uasset","This is where the vast majority of the logic is handled and starts. You have full control of when the component activates by calling the StartComponent function. When called, the component initializes the containers and the items inside or the pickup if the owning actor is a pickup. This does NOT prepare the widgets versions of the containers and the items.","To create the widget version of a container and its items, call BindContainerWithWidget and hook in the container struct and the container widget. This should give you full control of when you want to construct a container. Some examples would be when the player opens their inventory, but you don’t want to load all the items' attachment widgets. You could then load the attachment widgets when the player inspects the item. For inventory systems that can get massive with a lot of items inside of it with attachment widgets associated with it, this should massively improve performance and memory usage if used correctly.","For pickups, I recommend calling StartComponent on either BeginPlay or when the player is close to the item and has line of sight of the item, as items that have a spawn chance associated with it need that spawn chance rolled. The item might also have items attached to it and be visible, such as a sight on a gun, which also might have a spawn chance and you don’t want that sight to be visible if it failed its spawn chance.","The first category is Settings and most of these are instance editable, so you’ll be spending most of your time with these settings for your item actors.","ContainerSettings is where the majority of the work is done. I recommend going into AC_Inventory.h and find FS_ContainerSettings and looking at the comments for everything as there are some variables that aren’t instance editable.","The second category is UserSettings. It’s up to your settings system to update these if you want the player to be able to change these settings during runtime. RotateKey: While dragging an item, the player might want to rotate an item. When they press this key, it’ll rotate. SplitKey: While dragging a stackable item, when they drop the item onto a valid tile, they can split an item into two stacks.","Third category is ContainerSettings and this is where most of the colors used by the system are dictated. This is set in here so all the widgets can fetch colors easily and so designers can extend any color settings (for example color blind settings) to the user settings. If you want to add any color settings, this place is the preferred place. Item rarity colors are handled in here."]}],[{"l":"BP_PreviewActor","p":["File Location: Content\\Core\\Preview\\BP_PreviewActor.uasset","Under revision","This is an actor that “should” perfectly duplicate the appearance of any specific actor. It does this by getting all components of the owning actor and then duplicating it and reconstructing the hierarchy structure to match the hierarchy structure of the owning actor. This includes any attached actors.","It currently supports SceeneComponent, PrimitiveSceneComponent, ChildActorComponent, StaticMeshComponent and SkeletalMeshComponent. Though ChildActorComponent's are known to be extremely buggy and I personally don't suggest you use them with this system.","There is currently no way to disable BeginPlay, where as with Actor's you can with a ExposedOnSpawn boolean at the beginning of your BeginPlay logic. If you have any logic connected to your BeginPlay, you will need to find a way to disable it for the preview.","It should be easy to add compatibility for more components, you’ll have to add them yourself, but the currently supported components should support the vast majority of components that have any sort of visual importance. You can optimize the construction or simply prevent this actor from duplicating a specific component by going into ComponentTags and adding “DONOTPREVIEW”. Though remember, since the actor is trying to reconstruct the hierarchy setup inside your original actor, any components attached to components that you labeled as “DONOTPREVIEW” will break."]}],[{"l":"DA_CoreItem","p":["File location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Items\\DA_CoreItem.h File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Items\\DA_CoreItem.cpp","This is the data asset that is responsible for the base information for your items. I highly suggest looking at the DA_CoreItem.h file to see all the settings, functions and comments.","You can show and hide certain settings depending on your setup, and I use that a lot with the ItemType enum. Look at all the options, check out the meta properties (EditCondition and EditConditionHides) to see how it’s done, and you can then implement your own options and rulesets for their visibility.","Keep in mind, these settings are only HIDDEN, not disabled in the data asset editor, you can still access those variables from the data asset in blueprints and C++ and you have to remember that when making your functions and gameplay logic. One of the most important settings to set up here is EItemType as many functions use this enum to do casts to the proper children of this asset. Whenever you make a new child, remember to go into the .cpp file and set the default value. You can see an example inside all the .cpp children of this.","Currently your item actors must be a child of A_ItemPhysicalPresentation. If you want to change this, you can change it like so:"]}],[{"l":"O_ItemObject and AC_ItemDriver","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Objects\\Parents\\O_ItemObject.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Objects\\Parents\\O_ItemObject.cpp","File Location: Content\\Core\\ActorParents\\BP_O_ItemObject.uasset","File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Components\\AC_ItemDriver.h File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Components\\AC_ItemDriver.cpp","File Location: Content\\Core\\ActorParents\\BP_AC_ItemDriver.uasset","These are instanced UObjects, which are known for very buggy behavior, especially when you add networking into the mix. The way this system attempts to circumvent these problems is to create components which handle gameplay logic and attach it to the player.","Instanced UObjects are NOT intended to run much, if any logic, mainly it is meant to store data. But you can still have functions inside them, just like how you can with data assets, but it is important for you to know that these functions should not have delays, timers, async tasks or RPC’s. Do not write any data to these UObjects. The engine has had a notorious bug for a while where any data written to an instanced UObjects can sometimes modify the class itself on-disk.","For those types of logic, the ItemDriver is used. These are the actor components mentioned above and these can use the data from the UObject to run its logic. For example, you can have an UObject and ItemDriver designed to consume an item. The UObjects holds the data for how much health it restores and what animation to play, the ItemDriver is then responsible for driving that logic. It can then be re-used as often as you want in item data assets and change those variables without having to create a new UObject or ItemDriver. The data inside of the ItemDriver is meant to be written, and can be used just like any other actor component.","These components can also be viewed as a proxy between the inventory system and any other system. These UObjects and ItemDrivers have been designed to be completely independent from the system and extremely abstract, so you can modify them however you want without it affecting how the inventory works.","ItemDrivers have three replication methods; Server, Client and Both. Server ItemDriver's only exists on the server, client ItemDriver's only exists on the client, and Both are created on the server and replicated to the client. You’ll most likely be using Both most of the time. Clients are able to request the creation of an ItemDriver and pass in a tag, which you can associate with a function. This prevents those pesky situations where you are working on client code, for example a widget, and are trying to activate a function inside an item driver. The function GetItemDriver will create the driver for you, but if you are on the client and trying to create an ItemDriver set to Both, the function won’t be able to return it, because it has to send an RPC to the server which is not instant.","This function allows you to pass in a tag which will trigger any function you have associated with the tag once the ItemDriver is replicated. Look at the code comment for AC_ItemDriver.h-> ActivateEvent. If you are unfamiliar with GameplayTags, I highly recommend you start using them as they are extremely useful.","There is an annoying issue though, all variables that can be modified in blueprint will show up as editable variables in the instanced UObjects even if they aren’t set as Instance Editable (This might be a bug, if anyone knows a fix, please tell me). In the meantime, I’ve made it so any variables inside a DoNotShow category or with no category at all will not show up here. You can change the behavior inside O_ItemObject.h in the UCLASS macro. Remember you can create sub categories like so; DoNotShow|MyNewCategory. This should help keep all variables that are meant to be hidden organized. You can of course inverse this behavior in C++ by using the ShowCategory UCLASS specifier."]}],[{"l":"W_Attachment Parent","p":["File Location: Source\\InventoryFrameworkPlugin\\public\\Core\\Widgets\\W_AttachmentParent.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Widgets\\W_AttachmentParent.cpp","File Location: Content\\Core\\Widgets\\WBP_AttachmentParent.uasset","The parent widget for widgets that are used to hold the containers an item owns. For example, a gun has a sight and a magazine slot and you want to represent those slots with a container. That container needs to be hosted by some widget.","The base widget does not have any kind of layout so you are free to make any layout your project needs.","Both the C++ parent and the blueprint child are abstract, so it won't appear in any drop-down menus. These are designed for the intention to have children made from them."]}],[{"l":"W_Container","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Widgets\\W_Container.h File Location: Source\\InventoryFrameworkPlugin\\private\\Core\\Widgets\\W_Container.cpp","File Location: Content\\Core\\Widgets\\WBP_Container.uasset","This widget is responsible for holding both the tile widgets and item widgets and also acts as a proxy for the component to access any tile widgets or item widgets. The component ( AC_Inventory) should not rely on these widgets at all for any data for its functions, like I mentioned at the start of this documentation.","Even though there are ContainerSettings inside of these, they are immediately overridden by the component when created. They are mainly used as a fallback default, used for previewing how the container will look or used to bind the widgets to a specific container in a component. I recommend looking at the comment on GetContainerSettings.","To reduce the work for everyone when modifying containers, W_Container has a function ( GetContainerSettings) to get the ContainerSettings straight from the component it belongs to. This way you do not have to update the ContainerSettings for the widget every time the container is modified in any way and also allows designers to make children of W_Container and still have access to the same data as other children.","TileSize refers to how large you want your tile widgets to be. Ideally both dimensions should be the same to minimize stretching. If you decide to not have the dimensions 1:1, your item icons will have to accommodate for your new icon ratio. Yclamp refers to when you want the scroll bar to appear. This should be (Your Tile Y Size) * (How many Y tiles you want until the scroll bar appears) So if I want mine to appear after 8 tiles while my container is 10 tiles tall and my tile Y size is 60, I would do 8* 60.","TileClass and ItemClass are the default classes used to create the widgets for each instance of a container. It is recommended to try and keep these the same where ever your containers are to try and maintain consistent visuals through out your game.","DA_CoreItem has a override map, where if the current containers class if found in that map, it'll then use the item widget in that map instead of the assigned ItemClass. This could be useful for when a special item needs it own item widget."]}],[{"l":"W_Drag","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Widgets\\W_Drag.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Widgets\\W_Drag.cpp","File Location: Content\\Core\\Widgets\\DragAndSplit\\WBP_Drag.uasset","Visual representation of the item you are dragging, but also provides updates to W_Highlight whenever you hover over a tile so the highlight widget knows where to move.","All data you need when dragging and dropping an item should be stored in this widget.","Both W_Drag and W_Highlight are updated inside of WBP_Tile-> UpdateHighlight/ PerformDrop."]}],[{"l":"W_Highlight","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Widgets\\W_Highlight.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Widgets\\W_Highlight.cpp","File Location: Content\\Core\\Widgets\\DragAndSplit\\WBP_Highlight.uasset","The majority of the logic for this widget is done in C++ as it’s doing a lot of math on tick to achieve its animation style. There is a pure BP version of the tick logic in WBP_Highlight in case you aren’t a programmer and want to try out your own animation system or if you just want a blueprint version to read to better understand the C++ code if you aren’t familiar with C++.","There will be a second version without an animation style and will be designed more around performance (currently it can be a bit expensive if you have hundreds of tiles in one container) but that will be in a later version."]}],[{"l":"W_InventoryItem","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Widgets\\W_InventoryItem.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Widgets\\W_InventoryItem.cpp","File Location: Content\\Core\\Widgets","These are the widget representations of your item.","The GetItemData function automatically gets the direct struct version of the item it is representing from the component the item belongs to. This is so we don’t store the same item information in two places and whenever the item is updated you don’t need to update the widget as well.","This should allow for more designer friendly architecture, as you could make two children of this widget, one for example the normal inventory item widget the player has in their inventory and then another for vendors and you could have them store items in a list format and things would still work together.","WBP_InventoryItem is where icon generation is handled. It’s pretty straight forward, copying the behavior to other children should be simple. It uses the BP_PreviewActor to achieve this. The data asset editor window has a UI category which has various settings to adjust or optimize the generated icons."]}],[{"l":"W_Tile","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Widgets\\W_Tile.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Widgets\\W_Tile.cpp","File Location: Content\\Core\\Widgets\\WBP_Tile.uasset","There is very little logic or variables handled in this widget, as you have to keep in mind that this widget can end up with hundred copies or more, so it can get bad for memory allocation if overdone and if you don’t manage the variables those tiles are initializing.","Creating these tiles is by far the most expensive process I’ve found in this component. It is essential they store as little data and perform as few functions as possible so we can optimize the construction cost."]}],[{"l":"WBP_ContextMenu","p":["File Location: Content\\Core\\Widgets\\WBP_ContextMenu.uasset","This widget is a good example of a widget that is completely separated from the system, but just uses the item data to interact with the inventory system. You can manage the rules for each button and when they should be visible."]}],[{"l":"WBP_Drop","p":["File Location: Content\\Core\\Widgets\\DragAndSplit\\WBP_Drop.uasset","A simple widget that handles dropping an item. There’s nothing special about this, the context menu widget also has a drop function.","The widget simply sets the drop operation enum to DropItem","This causes DropItem function to get called by the component, which could look something like this"]}],[{"l":"WBP_Split","p":["File Location: Core\\Widgets\\DragAndSplit\\WBP_Split/uasset","Created by the drag widget when the player holds the split key. User is able to use the slider to decide how much they want to split an item, then the widget creates a new item with the selected amount."]}],[{"l":"Creating custom functions","p":["Once you’re comfortable enough in the system to make your own functions and/or change the current functions, here are some things to keep in mind.","You should always assume an item does not have a widget version of itself. If you need access to the widget of an item, you can use GetWidgetForItem. Remember to check if the widget is valid. Widgets also can’t be transported through a network, so if multiplayer is important to you, your server functions can’t rely on data from widgets."]},{"l":"Finding Items","p":["Finding an item is a very common scenario when you start making your own functions.","The container's TileMap combined with an item's UniqueID is the most reliable way of finding items.","The component includes a function to get an item at item at a specific index of a container GetItemAtSpecificIndex, then there is a bit more expensive way of finding an item but it’ll go through all containers, GetItemByUniqueID.","The UniqueID is the most reliable method of finding a very specific item, container or item driver, other than a direct reference to the item, container or item driver, but even then a direct reference might get outdated if the player moves the item or modifies it in some way. The UniqueID is only updated for containers and items if they are moved to a new component.","W_Tile also have a reference to the item on top of them, but to reduce memory, tiles have a OwningItem integer which references the top left tile of the item, which holds the ParentItem reference variable. So if you are inside the W_Tile and need to get the item it contains, you would use ParentContainer-> Tiles[ParentTile] -> OwningItem-> GetItemData. Remember to check if ParentTile is -1 first, as that means this tile widget doesn’t have any item inside of it."]},{"l":"Network optimizations","p":["It is recommended, where ever possible, to use the item or container UniqueID instead of the struct in your RPC calls, and then have your server use the UniqueID to figure out which struct to use.","Here you can see 2 sets of RPC calls. One is ReduceItemCount(indicated in red), which is passing the item struct to the server and then to the client. The other is IncreaseItemCount(indicated in blue), which is passing the UniqueID to the server and the server is then using that UniqueID to resolve what item we are trying to modify.","Switching to using the UniqueID method reduced the RPC size from around 75 bytes down to 13.","The only downside is that it is not possible to verify if the client has illegally modified it's data, and it's very difficult to verify that the data inside the item/container are synced. It is up to you whether that is a big enough problem to do this. Some anti-cheat methods already do a very good job at preventing clients from modifying the games data with external tools. If you need to validate the data, you can have the server function still accept the full item/container struct, validate the data, then only pass the UniqueID to the client."]}],[{"l":"Drag and drop","p":["A lot of the information PerformDrop function needs to do its calculations and logic should be stored in W_Drag. This is because setting and resetting all that information for all the tiles to optimize memory is simply just so much hassle compared to just putting your stuff in the drag widget, which is always just 1 of so it’s always optimized for memory and no hassle in managing it."]}],[{"l":"Objects and Drivers","p":["Item drivers should be destroyed after their logic is complete, especially if it’s from a stackable item. The reason being that it’s really hard or almost impossible to keep track of the stack it came from as that stack can be put into other stacks, split or fully used.","You must always keep in mind if the item driver is running logic that’s on a timer, you need to be aware that the item the driver belongs to might become invalid at any point. There is always the chance the item that owns the driver might get destroyed during the timer logic. I also recommend “locking” the player from interacting with the item during this timer or having some sort of failsafe if the player manipulates the item in some way while the timer is still running (For example; a gun playing its pickup animation and the player drops it mid-animation)"]}],[{"l":"Saving and loading","p":["Under revision","Everything is saved in structs, so it should be compatible with your save system. It’s up to your save and load system to manage this, but if you need an example, the demo project has an example of a simple save and load system.","But let’s be honest, Unreal Engine’s save system is not very good and lacks too many fundamental features. I recommend a plugin from the marketplace called Saviour."]}],[{"l":"Automation"}],[{"l":"Debugging","p":["Under revision"]},{"l":"Item Inspection","p":["WBP_Inspect has a ToggleDebug button on the top bar. You can use this for figuring out what rotation you want to feed into the generated icon settings. Pressing any of the XYZ buttons will rotate the mesh by the amount set in the slider. You can also manually put in a value in any of the text boxes. Zoom refers to the camera distance from the item."]}],[{"l":"Productivity"}],[{"l":"Quality Assurance"}],[{"l":"Versions"},{"l":"Version system","p":["Versions are labeled like so: MajorIteration. MinorIteration. Patches","MajorIteration: New features, small or large changes to existing files. Updating from one major iteration to anotherr might break some things and downgrading might be difficult.","MinorIterations: Adjustments to functions, optimizations. These updates should not break anything, but might still cause initial compile errors.","Patches: Bug fixes, crash fixes, anything that is minor and shouldn't cause any compile errors, these are generally safe to update to."]}],[{"i":"100","l":"1.0.0","p":["Initial release"]}],[{"i":"faq","l":"F.A.Q","p":["Under revision"]},{"i":"q-can-the-system-be-used-for-a-more-traditional-inventory-system-where-all-items-are-1x1","l":"Q: Can the system be used for a more traditional inventory system where all items are 1x1?","p":["A: Of course! The demos even include traditional inventory systems. There’s a lot of math and nested for loops being done with the idea of things being in different dimensions (also one of the main reasons why a lot of the components functions are in C++, as blueprints aren’t the best at math and nested for loops). But since all that math and nested for loops is being handled in C++, from my performance measurements there’s virtually no performance impact, even with massive items. With that in mind, this system should handle 1x1 items with ease."]},{"i":"q-is-there-a-crafting-system-implemented","l":"Q: Is there a crafting system implemented?","p":["A: No. This is an inventory system, not an inventory and crafting system. I know many assets on the marketplace already include a crafting system, but crafting systems are very genre dependent and often behave completely differently. I don’t think I can implement any sort of abstract base that can adapt to all scenarios. I feel like most people will either just not use the system I implement or remove it, and the time I spend implementing it will just raise the price. At the end of the day, crafting systems just require item data and some form of a “recipe”. It should not be difficult to create your crafting system with the item data system this asset uses and the functions the inventory component has. I might change my mind someday and attempt to implement some sort of abstract base, similar to what this plugin attempts to do for inventory systems."]},{"i":"q-will-statsattributes-or-ability-systems-of-any-kind-be-added","l":"Q: Will stats/attributes or ability systems of any kind be added?","p":["A: No. I believe most people should be using the Gameplay Ability System framework or something similar and there are a few ways to implement that system (I personally suggest GAS Companion from the marketplace). Some people also already have a stat/attribute or ability system in place and I do not want to step on their toes."]},{"i":"q-how-do-you-add-more-variables-to-items-and-create-new-item-types","l":"Q: How do you add more variables to items and create new item types?","p":["A: (Insert video tutorial here)"]},{"i":"q-will-i-be-adding-any-art-meshes-or-animations-to-the-asset","l":"Q: Will I be adding any art, meshes or animations to the asset?","p":["A: No, with the exception of some basic things like the Tile Icon and some other things, just enough so you don’t get any compile errors and can interact with the system before you implement your art. I dislike assets that sell themselves as one thing, but then start padding the asset with things that aren’t relevant to what the asset is advertising, which just raises the price and most people just end up removing those extra assets anyways. This is an inventory system and will always be just an inventory system."]},{"i":"q-will-i-be-adding-x-featuresystem-for-example-item-weight","l":"Q: Will I be adding X feature/system? For example item weight.","p":["A: Only if it’s a highly requested feature, only then will I either implement it into the base asset itself or make a youtube tutorial on how to implement it yourself."]}],[{"l":"Bugs"},{"l":"Known Bugs","p":["Under revision","There's a bug with the engine where if any item in your blueprint has Simulate Physics enabled, it'll remove the root component. There are some workarounds but none were perfect, especially with how flexible I wanted the system to be. UE5 preview fixed some issues but I immediately found new ones. There's an interface event called UpdateCollision and some items might need to override this function. It's default is in BP_SM_ItemPhysical and it should work in most projects.","WBP_Highlight is slightly not in the position it's supposed to be in. I’ve tried to solve this but it seems to be an issue with some floats getting truncated during some of the math. From my testing it was happening completely randomly so it’s been very challenging to diagnose. The Blueprint version is working just fine though. The performance difference between the two is almost none from my testing.","The BP_PreviewActor's animation is snapping to frame 0 of the animation it is supposed to play whenever the preview is refreshed. This is an issue I’m trying to solve. You can of course replace my actor preview system with a normal preview system, but those require a specific workflow and actor component hierarchy setup, whereas mine does not. This might take a while as I’m also trying to figure out a way to have particle effects also not get reset.","In 5.1, RenderTargets can break if your quality settings are below Epic."]},{"l":"Common Problems","p":["These aren't bugs, but problems that can be misinterpreted as bugs.","The WBP_Highlight widget and WBP_InventoryItem widget padding doesn’t take into account any scaling their parent widgets have to do (like borders). So if you are getting issues with items being dropped in a different tile or an item not lining up properly, there is most likely an issue with your UMG hierarchy/scaling. You might have this problem with scroll bars most of the time. An easy fix for that is to go into the ScrollBox, go into Scrollbar Padding, let's say the scroll bar is on the right side, go into the right side padding and minus the thickness of the bar.","BP_PreviewActor's automated camera distance is determined by all components which have collision enabled. This means if you have collision hitboxes or something similar on your actors, the camera will try to adjust to fit that in the camera view. Remember to use the tag “DONOTPREVIEW” on those collision components if the BP_PreviewActor is copying them."]}]]