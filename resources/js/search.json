[[{"l":"Inventory Framework Plugin"},{"i":"last-update-22nd-of-september-2023","l":"Last update: 22nd of September, 2023"},{"i":"latest-version-21","l":"Latest version: 2.1","p":["Links can be found at the top of the page. Introduction Video"]},{"i":"what-is-the-inventory-framework-plugin","l":"What is the Inventory Framework Plugin?","p":["Nearly every inventory system shares the same foundation, a container with tiles and items slot into those tiles. This Inventory Framework Plugin (IFP) attempts to be that foundation for your project, while allowing for a high level of inventory design, item customization, rapid prototyping and system integration.","From my research, inventory systems were taking 2-6 months or more (depending on how advanced it was) to be designed, bug tested, network tested and to be documented. With this framework, I try to provide you the framework needed to create your perfect inventory system and bring that initial creation time down.","What this provides is the C++ foundation for your programmers and a good Blueprint foundation for your designers, which includes:","Actor component and item parents that handle all the logic for you and are abstract enough so you can implement your mechanics and systems into it.","Widgets that are designer friendly (Easy to implement new logic, add animations to events, create children, etc). They also handle all the drag, drop, highlighting, splitting, combining logic and more.","Advanced data assets for your items instead of data tables.","A system that has no reliance on widgets to create or handle its data, meaning everything you need to know about an item is always accessible.","Container system that allows for infinite items inside of items. This means you can make a backpack, which has several containers, then a gun inside one of those containers and then that gun can have containers which have items inside of them. It can keep going for as long as you want.","Actor appearance duplication system that copies the appearance of your items allowing you to both inspect items and auto-generate icons. It works with all actors, not just item actors. No longer do you need to follow a hierarchy setup like many other inventory systems need. You can create your items however you want and the system will automatically duplicate the appearance for either generating item icons or letting you examine an item.","Powerful in-game and in-editor tools to improve quality control and speed up workflow.","It is NOT an inventory to fully replicate the mechanics of any specific game. If you want your system to behave like a specific game, you will have to implement those specific mechanics yourself. This system does try to provide you with the functions and data to replicate most inventory systems.","If you have any issues or questions neither the videos or documentation answer then feel free to message me on Discord (Variandaemon) or join the discord channel. You can look at the FAQ for more info."]},{"i":"color-sheet","l":"Color Sheet:","p":["functions- Variable- category- class"]}],[{"l":"Introduction","p":["This plugin was created for an open-world game that has very strict performance requirements. Because of this, some logic is handled in C++ as an inventory system like this does a lot of math. The design architecture is also designed to give programmers more control of when widgets and data is initialized. The architecture has also been made in mind for large-scale projects. This does mean though that there is a specific and strict workflow for setting up the component for items, especially sub containers. I've made an Editor Utility Widget called InventoryHelper which should prevent most human errors and allow people to work in the system without those strict requirements slowing down your creation process.","The architecture was made with designers in mind, so certain C++ functions can be overridden in Blueprints and some functions are only needed on the Blueprint level. This system is not meant to be purely C++ or Blueprints, rather a healthy mix of the two. If you can't write in C++ or don't have access to anyone who can write C++ code for you, the current functions should allow for you to create nearly any Blueprint logic you should need.","Data Assets are being used instead of Data Tables for a few reasons:","You can create children of the item data asset to create a brand new type of item with its own unique settings and not have those settings clutter the items that aren't relevant to those settings.","You can control their loading and unloading in the Asset Manager.","Easier to create Utility Widgets and automating tests.","It's easier to find out what assets are referencing which data asset, while with Data Tables, it can get messy to find out what asset is referencing a specific row.","Data tables are not ideal for managing massive databases. Anyone who has had to deal with source-control while working on an item will know the pains data tables can bring for a system like this.","For more advanced users, it’s possible to add slate widgets into the data asset editor window. For example, a recoil pattern editor for gun items.","The only con regarding data assets is you don’t get a nice table view like you get with data tables. But you can use the matrix editor which gives you a similar editor to the data tables and is in some ways even more powerful.","The plugin was designed to be installed locally to your project, not the engine. With how the marketplace works and how the engine works, it was much simpler to make this asset a plugin. This has also had the nice side effect of updating the system to be much easier.","Many things have been designed to be as abstract as possible and assume as little as possible about YOUR project and creation process. I do not want to dictate any creative vision and I do not want to step on any toes. I’ve tried to keep the system as painless as possible for you to integrate YOUR systems and assets with this inventory system, such as an attribute, ability or crafting system."]}],[{"l":"Installing the plugin","p":["Video walkthrough of the first steps: https://www.youtube.com/watch?v=78vurTeroX4","Because of how integral an inventory system is to a game, I highly recommend you DO NOT install the plugin to the engine and then use it that way, but instead install the plugin locally to your project. That way you can use the plugin in multiple projects without having a change that works in one project mess up the other project. This means you can also have much better control how the parents behave and work and not have to worry about changes made for another project. But it does mean updating the system is a bit more work, but it is very straight forward if you have source-control set up, as it'll tell you all the changes and you can reimplement any custom changes you made to suit your project. This is not mandatory, but can greatly help in the future when you want to update safely.","Once you are done installing the plugin (either locally or through the engine), I HIGHLY advise you make children of any class in this system once you want to modify the class. This should make updating in the future a lot easier and gives you a lot more customizability.","This does NOT cover how to install an IDE such as Rider or Visual Studio. You should already have an IDE installed. Unreal's docs for setting up Visual Studio There are also a few demo files that you’ll want to replace and enum entries you need to rename to fit your project.","Download the plugin through the Epic games client just like how you would download any other plugin.","If your project doesn’t have any C++ code, you will want to go into the engine and at the top go to Tools -> New C++ Class. It doesn’t matter what you create here or where you save it. This is just to get the engine to generate all the files you need to compile the plugin.","Go to your Unreal Engine installation -> Engine -> Plugins -> Marketplace and copy the InventoryFrameworkPlugin folder.","Go into your project's root folder (Where your .uproject is), create a folder called “Plugins” if you don’t have one.","Paste the InventoryFrameworkPlugin folder into the plugin folder.","Go back to your .uproject, right click and press \"Generate Visual Studio Project Files”.","Open the solution file with whatever IDE you use (For example Visual Studio or Rider) and build the project.","(Optional) You can now uninstall the plugin from the engine through the Epic Games Launcher, though you won't get notifications from the Epic Games client whenever an update is available (The discord announces every update as well).","The engine automatically enables the plugin the majority of the time. In rare cases, it might not enable it. If it didn't, open your project, go to Edit -> Plugins and search for \"Inventory Framework Plugin\" and make sure it's enabled.","Everything in the demo folder is designed to be replaced by your assets/Blueprints. It is only there so you don’t get any errors on startup."]},{"l":"Finding the plugin content in your content browser","p":["To find the blueprints, you will want to start the engine, go into your content browser and make sure that in your settings (1) and make sure \"Show Plugin Content\" (2) is checked. Once that is checked, you will find a \"Plugins\" folder and in there you will find \"InventoryFrameworkPlugin content\" (3)","If you decide to NOT install the plugin locally, you will also have to check \"Show Engine Content\" and then go into Engine -> Plugins -> InventoryFrameworkPlugin Content","It is highly recommended to head over to the How does the system work? page and giving a read before proceeding."]}],[{"l":"Asset Manager","p":["For the asset manager to pick up your item data base and for several tools to function correctly, you must set up the asset manager per project.","Go into Projects Settings.","Under the \"Game\" category, select \"Asset Manager\".","Add a new index and set \"Primary Asset Type\" as \"Items\", the asset base class to DA_CoreItem, then go into Directories and add all locations where you might store your items (This also searches sub folders)."]},{"l":"Adding custom asset types","p":["Inside your item data assets, you can see in the Developer Settings there's a \" Asset Registry Category\" variable. The default is \"Items\", just like the asset type we just set up in the asset manager.","You are able to either change the default for children of DA_CoreItem to be something unique, or change it per-item. If you have massive item data bases (500+ items), it is recommended to organize your data base using custom asset types.","Whatever you fill in inside of Asset Registry Category, you will need to follow the above steps, but replacing the Primary Asset Type with whatever you put into Asset Registry Category. You also must save the data asset manually after the change."]},{"l":"Validating","p":["To validate your items are being discovered correctly, I suggest going into the InventoryHelper and hitting Refresh near the bottom right. You can also search for your item.","If an item is not appearing there, either the above steps were not followed correctly or the asset manager is ignoring it for some reason. If you go into \"Windows\" and open the output log and find any \"Ignoring PrimaryAssetType Items - Conflicts with SOMECLASSNAME - Asset: ITEMNAMEHERE\" in your message log, it means no data has been changed inside of your data asset or it is identical to another data asset."]},{"l":"Limitations","p":["As of 5.1, there is still no way of mixing normal and blueprint data assets, for now you can only have normal data assets, and you can't do a lot of hierarchy setups. All of your parent files must live at a C++ level. Because the item data asset variable inside FS_InventoryItem lives in C++, there is no way to reference blueprint data assets. If you check \"Has Blueprint Classes\" the system will not work."]},{"l":"Bulk Editing","p":["You'll sometimes find yourself with tons of items and need to modify a large amount of items. This is where a good folder hierarchy setup is essential. In the demo project, every item is in its own folder, but all of those folders are inside DemoShowcase -> Items, if you go into the Items folder, find the filter on the left of the search bar and go into Miscellaneous -> Data Asset you will see every item inside the demo. If you select multiple, then right click and go into Asset Actions -> Bulk Edit Via Property Matrix, you'll find the property matrix editor.","Unreal's docs for the Property Matrix"]}],[{"l":"Adding the component and containers","p":["There are two components, one is the C++ parent and the other is the blueprint child of the C++ component. There is nothing stopping you from making your own BP component with the C++ component as its parent but I still recommend using the Blueprint component. You can also make a blueprint child of the blueprint component, which is the recommended path if you are going to override any functions. You want to add your component to your actor, if you're making an item, I suggest using BP_SM_PhysicalItem as its parent and the component will automatically get added. Do note though that the item Data Asset only accepts children of BP_SM_PhysicalItem. Go here if you want to change this behavior","Inside the component you'll find an array called ContainerSettings. These are your settings and where you'll add any items to the container. It is most common to give them a unique name, which you'll later use in the next step to assign them to a container widget. You will also need to set what kind of type this container is inside InventoryType and give the component a widget inside WidgetClass which it'll use to display its containers. Typically for player characters, this is the inventory screen. The order of these containers are important. There are many functions that try and find the first available container, which scans the containers from index 0 to the last index.","Now you'll need to bind your containers to a widget to represent the container. This is optional, there are cases where you might not want a container to have a widget representation. Though the player will not have a widget to interact with the container through. Go into your widget and add a child of WBP_Container to your layout. The plugin comes with a widget called WBP_DemoContainer which has all the visuals set up for you. Then go into your graph and implement the I_InventoryWidgets interface. Find the GetContainers interface function and make an array and add your containers. Somewhere throughout your logic you will need to call BindContainerWithWidget, you can see an example on how I call this function inside BP_Interactable or BP_PlayerCharacter.","The actor must implement the I_Inventory interface and override the GetInventoryComponent function and pass in a reference to the inventory component."]}],[{"l":"Activating the component"},{"l":"Starting the component","p":["Starting the component is very simple, just call AC_Inventory-> StartComponent. The bigger challenge will be deciding when you want to call this function. Typically this can be called at BeginPlay or when the player gets close to the actor. This will depend on some factors, the biggest being if any item inside the component will be visually present AND if they have a spawn chance. For example; a gun with a sight on it and the sight has a spawn chance. The sight's spawn chance might fail, and you might want the sight to get removed off the gun. Another example would be an NPC that is wearing some armor that has a spawn chance. If the armor fails its spawn chance, you'll probably want to modify some attributes and remove the armor.","This type of logic is very project dependant and depends on if the inventory component is eating up any impactful performance. I suggest leaving the StartComponent function on BeginPlay, and when it's time to optimize your games performance, then you start evaluating if calling StartComponent is more worthwhile being called at different times.","The order of the items inside every container is very important. If you hover over an items TileIndex you'll see your options. If an item is set to finding the first tile available or a random tile, then another item attempts to spawn on top of that item, it'll fail. There is a delegate which will fire whenever an item fails to spawn."]},{"l":"Stopping the component","p":["This function will remove all widgets and object references. Under no circumstances should this function be called while the player is actively interacting with the component. Here's a list of scenarios where you want to refrain from calling StopComponent.","The player will be interacting with the component within a short period of time, perhaps within 10 minutes.","If the player will be interacting with the component again, if the component has a lot of items or a lot of containers and it causes a noticable hitch when starting the component, it might be more efficient to keep the component active.","The component has items that have a spawn chance. Every time the component starts, it'll roll these spawn chances.","In a multiplayer scenario, you'll be eating a potentially large RPC call every time you start the component. If you stop the component and the player interacts with this component again, the StartComponent function will call a RPC that might be quite large.","The component can not be stopped while its Listeners array is not empty, which is used for multiplayer.","If your games memory usage is tight, it might be worthwhile trying to call StopComponent, but the above points must be kept in mind.","What might be worthwhile for you to optimize would be to try and clean up any widgets and object references the component is holding onto. That is most often the root of any performance issues after activating a component with a lot of items."]}],[{"l":"Equipping and unequipping items","p":["A big problem I try to solve with this system is that I did not want to assume anything about how your actors' meshes are set up, how your equipment setup looked like and I did not want to make a base player or actor blueprint. There are two main reasons behind this decision: First is this allows you complete control over what items are attached to (for example if you have a horse and want to give it armor, but the component is only setup on the player) and secondly is that people might already have a player blueprint hierarchy setup and I did not want to mess with that and some people might not want to use my hierarchy setup.","Your container's compatibility settings dictate what is allowed in them. If you only want helmets to go into container X, then your helmet items should use EquipmentSlot(Rename one of the options to Helmet) and your container should only allow Helmets. You can also of course rename one of the EquipmentType enum entries to “Head” and make your helmet item be of EquipmentType“Head” and then all items that might not be a helmet, but are a head item like glasses can go into that container.","The logic that runs the equipping and unequipping logic is stored in a object and item driver called IO_Equipment and ID_Equipment(if you are unfamiliar with the item driver system, I suggest getting familiar with it first) and they use a struct called EquipmentData, this struct attempts to solve most issues when it comes to having multiple skeletons, meshes or complex equipment logic, such as having a gun attached to a backpack which is attached to the player character and that gun has a sight attached to it or FPS shooter setups where you have a local arms skeleton and then a full body skeleton. This struct also attempts to keep the system away from hard coding any types of “main weapon” and “secondary weapon” or anything of the sort. I’ve found those types of setups often become cumbersome when a designer wants to add or remove these types of things.","Keeping the equipping system inside of a item driver provides a modular way for you to allow any item you want to be equippable, or trigger special animations when its added to an items container. It also allows you to easily implement your own system if you want without rewriting C++ code or affecting how the inventory system works at a fundamental level.","During my research, I found an astonishing amount of different workflows and processes. It was very daunting to try and solve all of them in one go, and maybe my system isn’t perfect, but it tries to solve as many as possible at once, while still being flexible and adjustable.","I recommend reading the comments in the EquipmentData struct (Found in IFP_CoreData.h) and going through ID_Equipment(which is an item driver found in the plugins folder Core -> ActorParents -> DriversAndObjects -> Equipment.) and look at the logic in there to get a better understanding of how the system is using this struct. I would explain it here, but it’s so long and extensive that explaining it in just text and pictures would take too long. This driver attempts to copy the system that is used in GAS with its PlayMontageAndWait function, which creates an object that handles the animation, but I wanted to keep mine inside of Blueprints."]},{"l":"Optimizations","p":["For weapons and equippables, I've implemented three methods of creating your equipment mesh (Item reperesentation):","Blueprint, this allows you to simply use any blueprint you've made as the item representation.","Skeletal mesh","Static mesh","Blueprint's are obviously the most expensive, but are the most customizable. I recommend staying away from using Blueprint's as your item representation whenever possible. For multiplayer, meshes are encouraged even more as they are very cheap to replicate.","For skeletal and static meshes, you gain access to most settings you would have in the details panel while editing them in a blueprint"]},{"l":"Notes regarding Skeletal and Static Meshes","p":["The default material section is not available (I assume this is an engine bug?). If you wish to change the default materials, go into Rendering -> Override Materials"]},{"l":"Notes for optimal multiplayer experience","p":["The way Unreal handles replication for attached actors is not the most elegant. When another player becomes relevant for another client, not all attached actors will get replicated within the same frame, and they might not even replicate in the order that you want them to. Leading to odd snapping or pop-in. This could be awkward if you have naked characters and then the clothing around them are blueprints.","This is another reason why it's suggested to stay away from blueprints for multiplayer, as with meshes, since they get attached to the actor itself, when it comes time to replicate it theres no snapping or pop-in. All components on an actor are replicated within the same frame.","There is always a chance a packet will be dropped, which is again why you should refrain from blueprints as the engine does a very good job ensuring every mesh component is replicated. For every blueprint, you're adding another actor, and another equipment manager component, and more RPC's and more RepNotify's and each of those have a chance to get dropped."]},{"l":"Notes on general equipment system design","p":["Equipping and unequipping items can get messy, most importantly it can get messy when players start spamming the system with animations, either by quickly equipping and unequipping an item really quickly or equipping multiple items, all trying to activate montages which will interrupt each other. In the demo, items do not play an animation when equipped or unequipped. But they do play an animation when you holster or unholster an item. If you're in multiplayer, the item will also be added to the network queue to prevent clients from spamming the server with RPC's. By default, there is no failsafe if an animation is interrupted as that is something most designers want to implement their own system into. Some designers might want players to be able to cancel animations or cancel the equip if it was interrupted. It is up to you to implement any sort of failsafe if players are finding ways to manipulate this animation cancelling in ways you don't like.","If you're going to have items visible on your character, it is recommended to have at least one setup for every item that instantly attaches the item to the desired location and mesh. This is so when you load a save, you won't get several animations playing at the same time and overlapping each other."]},{"i":"why-are-all-my-components-getting-renamed","l":"Why are all my components getting renamed?","p":["The system automatically tries to keep all components attached to an actor with unique names. Including attached actors. This is because of how the preview system works. The preview system attempts to reconstruct the actor it's previewing without fully cloning it. There are ways of perfectly cloning an actor, but those are very expensive and come with their own set of problems. The preview system only looks at the visible components on the actor, including attached actors, and reconstructs it. But problems occur if two components have the same name from 2 different attached actors. When the preview system reconstructs the actor, it finds out what component it was attached to, but it needs to know which component that is on itself, it can't use the object reference. This means that if two components have the same name, it'll mess up which component it should attach to. The simple fix to this is to make sure all components have a unique name. The engine already handles this if you attach a component to an actor and that actor has a component with the same name, but it does not do this for attached actors.","But to simplify debugging, only a underscore and a random number is added to the end of it. The rest of the name is untouched."]},{"i":"where-are-the-items-being-created","l":"Where are the items being created?","p":["A separate actor component called BP_AC_EquipmentManager is created and attached to the owning actor to handle the creation of items. This is handled this way because of replication. Before the system was replicated, this component didn't even exist and the system worked just like it does now.","This component is responsible for ensuring items are replicated in the correct order and attaching things in the correct order, in case an item got replicated before the item it is attached to is replicated."]}],[{"l":"Setting up vendors","p":["To have a inventory component be set to vendor, you will want to go into the component settings and set InventoryType to Vendor.","Right now, the system only considers items that are children of IDA_Currency.h as viable currencies that can be exchanged for a vendor item. Prices are calculated inside FL_InventoryFramework.h-> GetItemPrice, and the function that evaluates if a player can afford an item is AC_Inventory.h-> CanAffordItem. Remember, you can override an items price inside their override settings.","The system by default has an array of currencies which players can use to buy items, but it does not by default provide a way of allowing the player to select which currency to use to buy or sell an item. It simply uses the first available currency it can find. It's up to you to implement that sort of logic.","Most games tend to have vendors keep track of how much money the vendor has, then when you sell an item to the vendor they spend their own currency and grant it to the player. There are three vendors in the demo, each showing a different way of handling the vendor logic.","If a logic error occurs, for example trying to give the player currency, but they do not have enough space in their inventory, you can call a delegate called CurrencyAdditionFailed. This is where you might want to implement some sort of mail system or queue system, as it feels pretty bad for players when they sell an item and they don't get their currency for it. The demo does not include any system for handling this problem.","There are many ways of handling vendor behaviour. Nearly every game handles it slightly differently, which is why the framework does not try to handle any of this logic for you at a C++ level.","Instead, there are three points in the system where you can inject your own custom logic and rules for handling vendor interactions.","The function AC_Inventory.h-> CanAffordItem will call a interface function I_Inventory.h-> MeetsCurrencyCheck, this simply asks the owner of the component what they value the item as.","You can make a child of BP_AC_Inventory and override the CanAffordItem function to implement your own custom logic.","The buyer and seller will receive a delegate on both the server and client either after or before the transaction, the notify is handled inside of WBP_Tile-> PerformDrop-> MoveItem. The delegate is where you would perform any currency exchange, and since the vendor belongs to the server, it's allowed to call TryAddNewItem if you want to give either the vendor or player currency after the transaction."]}],[{"l":"Suggested Plugins","p":["This is a list of plugins that I personally suggest you use alongside this plugin. None of these are mandatory and completely optional."]},{"l":"GAS Companion","p":["Unreal Engine's built-in Gameplay Ability System (GAS) is extremely powerful and is becoming an industry standard. There is a problem with it though; it's very beginner-unfriendly. It's annoying to make attributes and can take a long time to set it up. The plugin GASCompanion does all the heavy lifting for you, has good documentation and good Discord support. I am not implementing a attribute or ability system with this system because I believe you should be using GAS (Either a plugin or your own implementation)."]},{"l":"Saviour","p":["The default save and load system in Unreal Engine is not good and is in desperate need of major revamp or improvements. While Saviour's documentation is a bit weird, the code underneath it is excellent and makes the save and load system triple A quality and the developer is very active on its forum thread. I will be supporting saving and loading with the default save system. I am not experienced enough in custom saving and loading to create a custom C++ solution."]},{"l":"Custom Thumbnails","p":["If you plan on having a large item data base and you have an icon artist, this plugin makes working with that data base way better."]},{"l":"UnrealImGui","p":["DearImGui is a great tool used in tons of game engines and is amazing for debugging your game. You can get blueprint support through ImGuiBlueprint(I have a personal repo where I've added more widget support) I sometimes use this plugin to quickly visualize data from a bunch of items while in-game."]},{"l":"EditorScriptingTools","p":["This plugin lets you customize the editor without touching C++. This way you can add UMG widget tools into the item data asset all inside blueprints and without touching the plugin."]}],[{"i":"how-does-the-networking-work","l":"How does the networking work?"},{"l":"Listeners","p":["Certain inventory data can become quite large, especially with how many containers and items you allow in an inventory. To optimize, we try to simplify things. Players only receive data from components that they request data from and data from their own components, but also any update from components they are currently interacting with.","The component keeps track of the players that are currently interacting with a component with the Listeners array, then whenever PlayerA moves, adds, removes or interacts with an item in some way, the component sends RPC calls to the other \"listeners\" so their widgets and data get updated.","For functions that modifies a components data, such as moving an item or modifying an items stack count or modifying any other data, you must remember that clients only have authority over their own component, they do not have authority over other components and thus can't call functions on other components. This is simply how networking in Unreal Engine works. Because of this, most functions require you to call the function on the component the client has authority over. Even though the item you are trying to modify is not on that component. This is why, when you look at some of the source code, the functions are getting the component the item belongs to through its UniqueID. ParentComponent and modifying that component's data through the component the client has authority over.","To simplify the code, any function that attempts to automate the replication for you stores its logic in a function with the same name but with a Internal_ prefix.","For most functions that modify data in some way, only a single version of that function is available for you to call, and that function handles the replication for you. This is to simplify the amount of functions exposed as it can get very daunting to try and handle every replication scenario and making sure your calling the right function. If you wish to modify how the replication is handled, you can always go into the functions, modify them, or enable the server/client/internal functions to be BlueprintCallable (Example would be AC_Inventory-> Internal_AdjustContainerSize)."]},{"l":"Code example"},{"i":"why-not-just-use-a-multicast-or-repnotify","l":"Why not just use a multicast or RepNotify?","p":["Because of how large some RPC's can get, I did not find multicasts to be acceptable for most of the functions. A lot of the RPC's are just simply not relevant for most clients anyways, and managing relevancy is a lot more complicated than a simple array of actors.","RepNotify's also can not be used because there is no way to ensure their order. When you label a RPC as \"Reliable\", Unreal will make sure all reliable RPC's get replicated in the order you called them. Variables will always get replicated, even with packet loss, so they are in a way \"reliable\", but not truly reliable. Variables will replicate whenever they get an opportunity to, and they have a lower priority than RPC's."]},{"l":"Unique ID","p":["The UniqueID is a simple method to quickly find containers or items, or ensuring containers or items are valid, and for linking some object to an item (Such as the item driver's). This is covered in multiple sections in the documentation, but here are some things to consider for networking.","Clients and servers must stay in sync when it comes to UniqueID's. This leaves you with two options;","Pre-generate the UniqueID's on the server, then pass them to the client and have your logic assign that UniqueID to the item. This is not advised as it can get bad for networking and it is generally cumbersome to program and manage it.","Use GenerateUniqueIDWithSeed. Now the only thing you need to ensure is that the client and server are using the same seed and they'll both generate the same UniqueID.","UniqueID's scale extremely well with RPC's. It is advised to use UniqueID's as often as possible.","There's no way to evaluate from a UniqueID if it was assigned to an item or container without going through all items and containers until you find a match. It is not recommended to add more information to this struct as it's meant to be small and simple, so that it gets replicated extremely quickly and cheaply.","UniqueID's from components the client does not have information on will not work. For example, two players are interacting with a chest and Player-1 moves an item from their inventory to the chest, Player-2 will not have the information necessary to move the item on their side, since they do not have the information needed from Player-1's inventory component. Some functions simply need more information than the UniqueID can provide."]}],[{"i":"how-does-the-system-work","l":"How does the system work?"},{"l":"Design structure","p":["With how strict the performance requirements were for this plugin, I’ve had to design this inventory system slightly differently from other systems you might find either on the marketplace or Youtube tutorials. The biggest thing to keep in mind is that this system does NOT rely on widgets being valid or created to keep track of its data.","This is to achieve five things:","This greatly speeds up widget construction since all the data they need (for example where an item is inside the container and so forth) is already prepped.","Allows you to remove widgets from RAM and still have the necessary data to find out important things like looting an item and finding a free space for that item.","Since widgets have way fewer references, there is less work to be done to manage widgets getting garbage collected properly.","Designers are able to create new widgets and prototype much faster since all the data they need about containers and items is always available from the component.","You have complete control over when you want to construct these widgets, meaning you can reduce lag spikes when starting your game or even speed up the time it takes for your players to load a level or area.","ContainerSettings is an array inside of AC_Inventory.h and it contains all the settings your designers will use and some settings only the programmers will use, and with all the settings combined you can figure out everything about that container.","When creating a widget for a container, the widget uses a UniqueID to find out what container it is representing.","Items differentiate themselves from each other by using a UniqueID as items can have the same name, same data asset and so forth, they can even share the same position inside a container while in-editor. A component can not give items or containers the same UniqueID twice. This is essential for functions to work properly.","The component is designed to live on individual actors, not the player controller. Though there is no reason why it can't live on the controller, but I won't be actively testing it that way.","It is highly recommended to head over to the AC_Inventory page and giving a read. Understanding the main component that makes this system work is crucial to understanding the in's and out's of the system."]},{"i":"how-are-the-infinite-items-inside-of-items-achieved","l":"How are the infinite items inside of items achieved?","p":["TLDR; Containers have coordinates explaining what item they belong to. The array is simply containers and those containers have an array of items. The only thing the compoonent needs to know whether a container is owned by the component or owned by an item is by checking FS_ContainerSettings. BelongsToItem.","I recommend reading the code comment for the container struct and then looking at AC_Inventory.h-> GetItemsContainers for an example."]}],[{"l":"Style Guide","p":["I have tried to follow the popular UE5 Style Guide. Though I may sometimes accidentally or purposefully sway from it. I am very open to criticism, if something is confusing or inconsistent, don't hesitate to let me know."]},{"l":"Functions","p":["Networking functions are prefixed with C_ for client, S_ for server and MC_ for multicast. For functions that attempt to automate replication, the bulk of the function's code is stored in a function with a Internal_ prefix. These are typically called both by the server and client. If you want access to the internal functions, you will need to add BlueprintCallable to the UFUNCTION above them."]},{"l":"Tools","p":["All editor utility widgets are stored inside Plugin folder -> Content -> Core -> Widgets -> EditorUtilityWidgets -> Tools. Any widgets or special components for each editor utility widget is stored in its own folder named after the editor utility widget inside the EditorUtilityWidgets folder. This is done so you can bookmark/favourite the Tools folder and have access to all the tools quickly. You can also find all your editor utility widgets at the top of the editor -> Tools -> Tools, though there is no way to separate the inventory tools from your own editor utility widgets."]}],[{"l":"Classes and Settings","p":["For all the classes that have a blueprint child, it is advised to use the blueprint as your parent for your classes, but is not mandatory. The blueprints have been designed to have children with your own custom logic and design.","All base classes will have a link to their documentation (if available) at the top of their header file or in the Event Graph."]}],[{"l":"A_ItemPhysicalRepresentation","p":["This is your physical representation of the item. If you already have items/weapons of any sorts, you will want to reparent those classes to this.","This is not supposed to run important logic as these can get destroyed and created by the user. (for example equipping and unequipping)","In your data asset, you can access this class so whenever you drop the item out of the inventory or want to spawn it in some way, here is how you access the original pickup class.","It’s very important when making your items that have a physical representation in the world and can be picked up that the component on that actor references the data asset that references this physical actor. Otherwise when you drop the item, it’ll spawn the wrong class.","The setup for pickups goes like this: In your ContainerSettings index 0, you set ContainerType to ThisActor and item index 0 is the pickup data asset. There should be no other items in this items array. Containers that might be attached to the pickup are added after and they can have Inventory or Equipment selected, but never CurrentItem."]},{"l":"Actor Item Physical Representation","p":["File location: InventoryFrameworkPlugin\\Public\\Core\\Actors\\Parents\\A_ItemPhysicalRepresentation.h File location: InventoryFrameworkPlugin\\Private\\Core\\Actors\\Parents\\A_ItemPhysicalRepresentation.cpp"]},{"i":"blueprint-child-bp-sm-itemphysical","l":"Blueprint Child: BP_SM_ItemPhysical","p":["File location: Content\\Core\\ActorParents\\BP_SM_ItemPhysical.uasset"]},{"l":"Custom Blueprint Children","p":["The BP_SM_ItemPhysical is a optional parent in your hierarchy. It has some code that you will want to copy over to any parents that you have if you wish to make your own, primarily the BeginPlay, Equip and Unequip delegates, and Destroyed event.","The C++ inventory compoonent will automatically get added to your actor, but the base C++ version should not be used. You want to click on the InventoryComponent in your components list and set ComponentClass to BP_AC_Inventory (Or your own child of the inventory component if you've made one)"]}],[{"l":"AC_Inventory","p":["This is where the vast majority of the logic is handled and starts. You have full control of when the component activates by calling the StartComponent function. When called, the component initializes the containers and the items inside or the pickup if the owning actor is a pickup. This does NOT prepare the widgets versions of the containers and the items. But this function must be called before you display any widgets or any data to the player.","To create the widget version of a container and its items, call BindContainerWithWidget and hook in the container struct and the container widget. This should give you full control of when you want to construct the widget for a container. Some examples would be when the player opens their inventory, but you don’t want to load all the items' attachment widgets. You could then load the attachment widgets when the player inspects the item. For inventory systems that can get massive with a lot of items inside of it with attachment widgets associated with it, this massively improve performance and memory usage if used correctly.","For pickups, I recommend calling StartComponent on either BeginPlay or when the player is close to the item and has line of sight of the item, as items that have a spawn chance associated with it need that spawn chance rolled. The item might also have items attached to it and be visible, such as a sight on a gun, which also might have a spawn chance and you don’t want that sight to be visible if it failed its spawn chance."]},{"l":"Actor Component Inventory","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Components\\AC_Inventory.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Components\\AC_Inventory.cpp"]},{"i":"blueprint-child-bp-ac-inventory","l":"Blueprint Child: BP_AC_Inventory","p":["File Location: Content\\Core\\Components\\BP_AC_Inventory.uasset"]},{"l":"Settings","p":["The first category is Settings and most of these are instance editable, so you’ll be spending most of your time with these settings for your item actors.","ContainerSettings is where the majority of the work is done. I recommend going into IFP_CoreData.h and find FS_ContainerSettings and looking at the comments for everything as there are some variables that aren’t instance editable."]},{"l":"User Settings","p":["The second category is UserSettings and these are settings that are meant to be used by the player during runtime. It’s up to your settings system to update these if you want the player to be able to change these settings during runtime. The input system is extremely basic and is meant to be replaced. They are never used at a C++ level, so your designers can replace it easily. RotateKey: While dragging an item, the player might want to rotate an item. When they press this key, it’ll rotate. SplitKey: While dragging a stackable item, when they drop the item onto a valid tile, they can split an item into two stacks."]},{"l":"Color settings","p":["Third category is ColorSettings and this is where most of the colors used by the system are dictated. This is set in here so all the widgets can fetch colors easily and so designers can extend any color settings (for example color blind settings) to the user settings. If you want to add any color settings, this place is the preferred place. Item rarity colors are handled in here."]},{"l":"Network Queue","p":["The component has an array called NetworkQueue, these are items that are waiting for a server RPC to finish. If you are writing your own networking code, it is up to you to call C_AddItemToNetworkQueue and C_RemoveItemFromNetworkQueue. This will automatically call ItemAddedToNetworkQueue or ItemRemovedFromNetworkQueue.","If the item widget is available, it'll also call: W_InventoryItem-> ParentItemAddedToNetworkQueue/ ParentItemRemovedFromNetworkQueue","These events are where your designers hook in any logic that alerts the player the item is pending some networking event. This is most often seen as making the item's icon gray-scale or flashing the icon.","You will want to implement some way of preventing players from interacting with items that are pending a network event, either by making the widget uninteractable or through code. You can check if an item is in the queue by using: FL_InventoryFramework.h-> IsItemInNetworkQueue","The Network Queue system is only relevant for clients, it's never used in single player or server scenarios."]},{"l":"Infinite containers","p":["Containers can be infinite in either the X or Y direction, the system tries to dynamically resize the container whenever an item is moved, added or removed from it."]},{"l":"States","p":["The containers can be in one of three states during development.","The \"raw\" state is where UniqueID's are not set and containers BelongsToItem directions are direct index directions and all object references are null. The component is designed to be in this state for when you call the StartComponent function. This is where all the data is \"human readable\", but most functions won't work.","The \"Editor\" state is where Unique's have been initialized and BelongsToItem are set to the items and containers UniqueID's and some object references might be valid. This state is meant for development and it might make some data not human-readable, and it'll mean most of your functions will work as if you are in a valid game session. Many tools depend on the component being in this state, such as the InventoryHelper.","Finally there's the \"Initialized\" state. This simply means the gameplay logic has called the StartComponent function and you are inside a gameplay session. The component should never be put into this state while you're outside of a game session.","You can use GetComponentState to resolve what state it is in, and look inside that function to better understand what conditions must be met for each state.","There is a function called ConvertToRawState which will prepare all containers for a gameplay session. Ideally, this function should not be called during a gameplay session as it's a waste of CPU time. All container data should already be prepped for gameplay. By default, the component calls this function on its BeginPlay if it detects the actor was not setup properly and spit out a print string. There is also another function called ConvertFromRawStateToEditorState which preps all data to be usable for editor tools."]},{"l":"Attached spawned items","p":["An important aspect to remember is that whenever you have a item that has a spawned actor to represent it, such as a gun item inside the players equipment container, the inventory component on the spawned item should NOT be used.","This will mostly happen with the equipment system when using Blueprint items. The reason for this is because spawned blueprints can be deleted and restored over and over, so they are unreliable to store any important data. It would also mean that the blueprint would always have to stay alive if you wanted to explore the items containers while the item isn't spawned (In this example, the gun item hasn't been equipped). An items containers always live on the component that own the item, (In this example, the gun's containers live on the character that is holding the gun).","To retrieve the items true data, you need to retrieve the UniqueID of the owning item in some way. Generally this means storing the items UniqueID inside your spawned blueprint. BP_SM_ItemPhysical does this through an interface event called PassUniqueID and stores the data inside RootItemData."]}],[{"l":"BP_PreviewActor","p":["This is an actor that “should” perfectly duplicate the appearance of any specific actor. It does this by getting all components of the owning actor and then duplicating it and reconstructing the hierarchy structure to match the hierarchy structure of the owning actor. This includes any attached actors.","It currently supports SceneComponent, PrimitiveSceneComponent, ChildActorComponent, StaticMeshComponent and SkeletalMeshComponent.","It should be easy to add compatibility for more components, you’ll have to add them yourself, but the currently supported components should support the vast majority of components that have any sort of visual importance. You can optimize the construction or simply prevent this actor from duplicating a specific component by going into ComponentTags and adding “ DONOTPREVIEW”. Though remember, since the actor is trying to reconstruct the hierarchy setup inside your original actor, any components attached to components that you labeled as “ DONOTPREVIEW” will break.","This actor will render out a render target for you to use however you wish and this is how the item icon generation is handled.","Even though the render scene component only see’s the preview actor itself and it only receives lighting from lighting channel 1 (Channel can be changed, but it’s recommended not to have it on 1 if your game has day/night cycles), BP_PreviewActor’s lighting can still affect another BP_PreviewActor. Even while spawning them at a ridiculously long range of random locations, during my playtesting I still had this scenario happen. To fix this, there’s a BP_PreviewActorCollider which you will spawn first, which will test for collision and adjust its location. Then you spawn BP_PreviewActor itself and set its location inside the collider.","This does mean though that you need to handle the collision responses for this. I recommend creating a new collision channel for BP_PreviewActor and BP_PreviewActorCollider."]},{"l":"Blueprint Preview Actor","p":["File Location: Content\\Core\\Preview\\BP_PreviewActor.uasset"]},{"i":"notes-regarding-span-style-color-violet-childactorcomponent-span-s","l":"Notes regarding <span style=\"color:violet\">**ChildActorComponent**</span>'s","p":["There is currently no way to disable BeginPlay, where as with Actor's you can with a ExposedOnSpawn boolean at the beginning of your BeginPlay logic. If you have any logic connected to your BeginPlay, you will need to find a way to disable it for the preview if there's any logic you don't want the preview to run.","If possible, avoid ChildActorComponent's. They are extremely prone to bugs and odd behaviour, and they don't seem to play well with networking."]},{"l":"Camera management","p":["The BP_PreviewActor will attempt to find the first component which has a socket called “PreviewCameraSocket” and attach the camera to that socket. If none is found, you’ll get an error message and the camera will stay attached to the PreviewActor’s root. Ideally, all your meshes should have this socket that you want to use this actor on. But to improve prototyping, I’ve added a few options to the item data asset:","Once you're far enough into production or willing to keep all meshes up to date with the socket, you should remove these four settings.","The actor supports auto-generated estimated camera distances, so you don’t have to debug every item to create a camera distance while in a prototyping phase. You can disable this by checking Use Custom Arm Length."]},{"l":"Skeletal Meshes","p":["The default animations for skeletal meshes is retrieved via an interface function GetEquipmentData. This allows you to assign what animations the previewed skeletal mesh will play. For now it is only looping one animation, but an animation blueprint can be added to this struct if you wish."]},{"l":"Optimizations","p":["It is also up to you to manage the render targets and when they should be released from the GPU. You can see an example in WBP_InventoryItem-> TryReleaseGeneratedIcon. I’ve tried to automate the release and creation for the widgets that come with this plugin, but if you are making a new widget and are new to render scene components, you must call ReleaseRenderTarget2D for the texture.","It is hard to create a perfectly automated system, so if you ever encounter an icon vanishing for an item, that means the render target was released improperly. During your prototyping phase, I recommend you just release and wipe the references when the player closes their inventory. Then when you’re in your optimization phase, you can try to optimize this. Do keep in mind that live captures can get very expensive, very quickly, since they are capturing a new image every frame.","You can limit it by enabling CaptureEveryFrame and limiting the TickInterval inside of SceneCaptureComponent2D.","I have these disabled by default, so if your actor isn’t animating, you need to enable CaptureEveryFrame, or if you're duplicating an item, you can go into its data asset and disable UseStaticCapture."]}],[{"l":"DA_CoreItem","p":["This is the data asset that is responsible for the base information for your items. I highly suggest looking at the DA_CoreItem.h file to see all the settings, functions and comments.","You can show and hide certain settings depending on your setup, and I use that a lot with the ItemType enum. Look at all the options, check out the meta properties (EditCondition and EditConditionHides) to see how it’s done, and you can then implement your own options and rulesets for their visibility.","Keep in mind, these settings are only HIDDEN, not disabled in the data asset editor, you can still access those variables from the data asset in blueprints and C++ and you have to remember that when making your functions and gameplay logic. One of the most important settings to set up here is EItemType as many functions use this enum to do casts to the proper children of this asset. Whenever you make a new child, remember to go into the .cpp file and set the default value. You can see an example inside all the .cpp children of this.","If you are new to C++ or Unreal Engine, I suggest looking here to find all the specifiers you can give each variable."]},{"l":"Data Asset Core Item","p":["File location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Items\\DA_CoreItem.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Items\\DA_CoreItem.cpp"]},{"l":"Changing the Physical Actor class","p":["Currently your item actors must be a child of A_ItemPhysicalPresentation. If you want to change this, you can change it like so:","AActor can be swapped out for any class, it does not need to be AActor, but it must be a child of AActor."]},{"l":"Custom shapes","p":["This inventory system features container styles where items can be different lengths and different heights. The way you define your shape is by adding the Custom Shape object to your ObjectsAndDrivers array and using the DisabledTiles array. Though this is not very pleasant to work with in its raw array format. It is recommended to use the ItemEditor, where you'll find a toolbox with a few tools inside of it, one being the shape editor. Which gives you a much better UI to work with."]},{"l":"Asset verification","p":["To aid quality assurance, the data asset has a \"Verify Data\" button at the top of the asset. The verification validates everything in the following process:","Use the ValidationClass in the DeveloperSettngs category to execute its VerifyData function. (Because we can't use Blueprint data assets, this step is used to get around that limitation.)","ValidationClass-> VerifyData will run some code to check if any mistakes have been made. Since every project is different, it is suggested to create your own child of O_ItemAssetValidation and write your own code. To validate the data of object references, an interface function from the I_Validation.h interface also named VerifyData is called. You can see an example of this inside of O_BasicItemValidation and IO_Consumable","If any error messages are created during any of the VerifyData functions, you'll get a message at the bottom right stating the error message. If the ErrorMessages array is empty, the item passes the verification.","Do note, if an item does not pass the verification, it does NOT prevent you from playing the game."]}],[{"l":"O_ItemObject and AC_ItemDriver","p":["Ever wanted to tie gameplay logic to your items without cluterring up your character and AI blueprints? If so, then this is the place for you!","These are instanced UObjects which allow you to edit variables inside the item data asset and actor components that run gameplay logic, using the UObjects data.","Instanced UObjects are NOT intended to run much, if any logic, mainly it is meant to store data. But you can still have functions inside them, just like how you can with data assets, but it is important for you to know that these functions should not have delays, timers, async tasks or RPC’s. Do not write any data to these UObjects.","For those types of logic, the ItemDriver is used. These are simple actor components that can use the data from the UObject to run its logic. For example, you can have an ItemObject and ItemDriver designed to consume an item. The ItemObject holds the data for how much health it restores and what animation to play, the ItemDriver is then responsible for driving that logic. It can then be re-used as often as you want in item data assets and change those variables without having to create a new ItemObject or ItemDriver. The data inside of the ItemDriver is meant to be written, and can be used just like any other actor component.","These components can also be viewed as a proxy between the inventory system and any other system. These ItemObject and ItemDrivers have been designed to be extremely abstract, so you can modify them however you want without it affecting how the inventory works. There's very few aspects of the inventory that depend on this system, one being responsible for making sure equipped items get attached to the player character.","ItemDrivers have three replication methods; Server, Client and Both. Server ItemDriver's only exists on the server, client ItemDriver's only exists on the client, and Both are created on the server and replicated to the client. You’ll most likely be using Both most of the time. Clients are able to request the creation of an ItemDriver and pass in a tag, which you can associate with a function. This prevents those pesky situations where you are working on client code, for example a widget, and are trying to activate a function inside an item driver. The function GetItemDriver will create the driver for you, but if you are on the client and trying to create an ItemDriver set to Both, the function won’t be able to return it, because it has to send an RPC to the server which is not instant.","This function allows you to pass in a tag which will trigger any function you have associated with the tag once the ItemDriver is replicated. Look at the code comment for AC_ItemDriver.h-> ActivateEvent. If you are unfamiliar with GameplayTags, I highly recommend you start using them as they are extremely useful.","There is an annoying issue though, all variables that can be modified in blueprint will show up as editable variables in the instanced ItemObject even if they aren’t set as Instance Editable (This might be a bug, if anyone knows a fix, please tell me). In the meantime, I’ve made it so any variables inside a DoNotShow category or with no category at all will not show up here. You can change the behavior inside O_ItemObject.h in the UCLASS macro. Remember you can create sub categories like so; DoNotShow|MyNewCategory. This should help keep all variables that are meant to be hidden organized.","There is an option to have drivers \"follow\" the item. In C++, you are able to detach and attach actor components from one actor to another. With this setting enabled, the driver will do its best to follow the item where ever it goes. That means moving the item from your inventory to another or dropping the item and the item creating its own physical actor will receive the already existing item driver. Any timers and variables are kept alive as this is a non-destructive process.","Whenever possible, use soft references and try to avoid hard references. Item data bases are one of the fastest ways of creating a nasty web of hard references and before you know it, the majority of your game is loaded at times where you don't want it to be. These objects are potentially the biggest culprit in this system to create that kind of nasty web of hard references."]},{"l":"Object Item","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Objects\\Parents\\O_ItemObject.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Objects\\Parents\\O_ItemObject.cpp"]},{"i":"blueprint-child-bp-o-itemobject","l":"Blueprint Child: BP_O_ItemObject","p":["File Location: Content\\Core\\ActorParents\\BP_O_ItemObject.uasset"]},{"l":"Actor Component Item Driver","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Components\\AC_ItemDriver.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Components\\AC_ItemDriver.cpp"]},{"i":"blueprint-child-bp-ac-itemdriver","l":"Blueprint Child: BP_AC_ItemDriver","p":["File Location: Content\\Core\\ActorParents\\BP_AC_ItemDriver.uasset"]},{"l":"Data-only objects","p":["Objects do not need to a driver to go along with it. Sometimes all you need is a place to store variables, and while you can add those variables to the data asset itself, some people do not want to go into C++ OR there is some data that can't be categorised to an item category. For example; quest data. Any item can be a part of a quest, but you might not want create a data asset parent dedicated to a quest category.","For data-only objects, it's recommended to use O_PureItemObject as the parent for your object.","You can then retrieve this data by using the GetObjectsByTag/ GetObjectsByClass. The class version will automatically cast to the correct blueprint. For the tag version, you manually have to cast to your blueprint."]},{"l":"Tips and tricks","p":["By default, your objects will display their default class name in the drop down menu.","You can change the name they are given inside this drop down menu by following the next steps.","By going into your Class Settings (1) you can change the class name (2). The drop down menu will now display whatever text you put in here."]}],[{"l":"W_Attachment Parent","p":["The parent widget for widgets that are used to hold the containers an item owns. For example, a gun has a sight and a magazine slot and you want to represent those slots with a container. That container needs to be hosted by some widget.","The base widget does not have any kind of layout so you are free to make any layout your project needs.","Both the C++ parent and the blueprint child are abstract, so it won't appear in any drop-down menus. These are designed for the intention to have children made from them."]},{"l":"Widget Attachment Parent","p":["File Location: Source\\InventoryFrameworkPlugin\\public\\Core\\Widgets\\W_AttachmentParent.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Widgets\\W_AttachmentParent.cpp"]},{"i":"blueprint-child-wbp-attachment","l":"Blueprint Child: WBP_Attachment","p":["File Location: Content\\Core\\Widgets\\WBP_AttachmentParent.uasset"]}],[{"l":"W_Container","p":["This widget is responsible for holding both the tile widgets and item widgets and also acts as a proxy for the component to access any tile widgets or item widgets. The component ( AC_Inventory) should not rely on these widgets at all for any data for its functions, like I mentioned at the start of this documentation.","Even though there are ContainerSettings inside of these, they are immediately overridden by the component when created. They are mainly used as a fallback default, used for previewing how the container will look or used to bind the widgets to a specific container in a component. I recommend looking at the comment on GetContainerSettings.","To reduce the work for everyone when modifying containers, W_Container has a function ( GetContainerSettings) to get the ContainerSettings straight from the component it belongs to. This way you do not have to update the ContainerSettings for the widget every time the container is modified in any way and also allows designers to make children of W_Container and still have access to the same data as other children.","TileSize refers to how large you want your tile widgets to be. Ideally both dimensions should be the same to minimize stretching. If you decide to not have the dimensions 1:1, your item icons will have to accommodate for your new icon ratio. Yclamp refers to when you want the scroll bar to appear. This should be (Your Tile Y Size) * (How many Y tiles you want until the scroll bar appears) So if I want mine to appear after 8 tiles while my container is 10 tiles tall and my tile Y size is 60, I would do 8* 60.","TileClass and ItemClass are the default classes used to create the widgets for each instance of a container. It is recommended to try and keep these the same where ever your containers are to try and maintain consistent visuals through out your game.","DA_CoreItem has a override map, where if the current containers class is found in that map, it'll then use the item widget in that map instead of the assigned ItemClass. This could be useful for when a special item needs it own item widget."]},{"l":"Container","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Widgets\\W_Container.h File Location: Source\\InventoryFrameworkPlugin\\private\\Core\\Widgets\\W_Container.cpp"]},{"i":"blueprint-child-wbp-container","l":"Blueprint Child: WBP_Container","p":["File Location: Content\\Core\\Widgets\\WBP_Container.uasset"]},{"i":"demo-widget-wbp-democontainer","l":"Demo widget: WBP_DemoContainer","p":["File Location: Content\\Demo\\Widgets\\WBP_DemoContainer.uasset"]}],[{"l":"W_Drag","p":["Visual representation of the item you are dragging, but also provides updates to W_Highlight whenever you hover over a tile so the highlight widget knows where to move.","All data you need when dragging and dropping an item should be stored in this widget.","Both W_Drag and W_Highlight are updated inside of WBP_Tile-> PerformDrop and BP_AC_Inventory-> UpdateHighlight","The chain of events begin at WBP_InventoryItem-> OnDragDetected. An important note to consider is that Epic, in their ever-ending glorious top tier coding, have a built in interpolation for the drag and drop drag visual that you CAN NOT interact with without modifying the engine. But you have to go through a lot of trouble to replace the built-in drag and drop system for Unreal. So I leave the drag visual for the drag/drop operation as empty and allow WBP_Drag to drive the visuals and most of the logic. The Drag/Drop operation is primarily just used to trigger the \"On Drop\" events."]},{"l":"Widget Drag","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Widgets\\W_Drag.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Widgets\\W_Drag.cpp"]},{"i":"blueprint-child-wbp-drag","l":"Blueprint Child: WBP_Drag","p":["File Location: Content\\Core\\Widgets\\DragAndSplit\\WBP_Drag.uasset"]}],[{"l":"W_Highlight","p":["This widget is the primary method used for handling the highlight for moving items. An alternative method is used inside the InventoryHelper tool."]},{"l":"Widget Highlight","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Widgets\\W_Highlight.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Widgets\\W_Highlight.cpp"]},{"i":"blueprint-child-wbp-highlight","l":"Blueprint Child: WBP_Highlight","p":["File Location: Content\\Core\\Widgets\\DragAndSplit\\WBP_Highlight.uasset"]}],[{"l":"W_InventoryItem","p":["These are the widget representations of your item.","The GetItemData function automatically gets the direct struct version of the item it is representing from the component the item belongs to. This is so we don’t store the same item information in two places and whenever the item is updated you don’t need to update the widget as well.","This should allow for more designer friendly architecture, as you could make two children of this widget, one for example the normal inventory item widget the player has in their inventory and then another for vendors and you could have them store items in a list format and things would still work together.","WBP_InventoryItem-> GenerateItemIcon is where icon generation is handled. It’s pretty straight forward, copying the behavior to other children should be simple. It uses the BP_PreviewActor to achieve this. The data asset editor window has a UI category which has various settings to adjust or optimize the generated icons."]},{"l":"Widget Inventory Item","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Widgets\\W_InventoryItem.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Widgets\\W_InventoryItem.cpp"]},{"i":"blueprint-child-wbp-inventoryitem","l":"Blueprint Child: WBP_InventoryItem","p":["File Location: Content\\Core\\Widgets"]},{"i":"demo-widget-wbp-demoinventoryitem","l":"Demo widget: WBP_DemoInventoryItem","p":["File Location: Content\\Demo\\Widgets\\WBP_DemoInventoryItem.uasset"]}],[{"l":"W_Tile","p":["There is very little logic or variables handled in this widget, as you have to keep in mind that this widget can end up with hundred copies or more, so it can get bad for memory allocation if overdone and if you don’t manage the variables those tiles are initializing.","Creating these tiles is by far the most expensive process I’ve found in this component. It is essential they store as little data and perform as few functions as possible so we can optimize the construction cost."]},{"l":"Widget Tile","p":["File Location: Source\\InventoryFrameworkPlugin\\Public\\Core\\Widgets\\W_Tile.h File Location: Source\\InventoryFrameworkPlugin\\Private\\Core\\Widgets\\W_Tile.cpp"]},{"i":"bluerint-child-wbp-tile","l":"Bluerint Child: WBP_Tile","p":["File Location: Content\\Core\\Widgets\\WBP_Tile.uasset"]},{"i":"demo-widget-wbp-demotile","l":"Demo widget: WBP_DemoTile","p":["File Location: Content\\Demo\\Widgets\\WBP_DemoTile.uasset"]}],[{"l":"WBP_ContextMenu","p":["This widget is a good example of a widget that is completely separated from the system, but just uses the item data to interact with the inventory system. You can manage the rules for each button and when they should be visible."]},{"l":"Widget Blueprint Context Menu","p":["File Location: Content\\Core\\Widgets\\WBP_ContextMenu.uasset"]}],[{"l":"WBP_Drop","p":["A simple widget that handles dropping an item. There’s nothing special about this, the context menu widget also has a drop function.","The widget simply sets the drop operation enum to DropItem","This causes DropItem function to get called by the component, which could look something like this"]},{"l":"Widget Blueprint Drop","p":["File Location: Content\\Core\\Widgets\\DragAndSplit\\WBP_Drop.uasset"]}],[{"l":"WBP_Split","p":["Created by the drag widget when the player holds the split key. User is able to use the slider to decide how much they want to split an item, then the widget creates a new item with the selected amount."]},{"l":"Widget Blueprint Split","p":["File Location: Core\\Widgets\\DragAndSplit\\WBP_Split/uasset"]}],[{"l":"Adding new items during runtime"},{"l":"Single player","p":["Adding new items during runtime for single player is no problem and has no restrictions. Just call the function AC_Inventory-> TryAddNewItem."]},{"l":"Multiplayer","p":["For multiplayer though, I've had to wrap this function with a very strict safe guard. Clients are under no circumstance allowed to call this function. If they do find a way, they will get kicked. There is simply no circumstance where the client should even have the slightest chance of gaining access to this function as they could potentially feed it bad data and grant themselves any item within your data base.","Only the listen server or dedicated server is allowed to use this function.","This means if you have a quest system or anything of the sort where the player is granted an item, you will have two options:","Pre-store the item in a component and call the MoveItem function, but this will permanently remove the item from the old component. Though you could always reset the data after the function is called.","The system which is calling TryAddNewItem is already owned by the server, and thus is allowed to call the function legally."]},{"l":"Example","p":["Here is an example of adding a backpack to another component with another backpack inside of it, and that backpack having items inside of it. If your item has no containers, just make an empty array for the ItemsContainers"]}],[{"l":"Creating custom functions","p":["Once you’re comfortable enough in the system to make your own functions and/or change the current functions, here are some things to keep in mind.","You should always assume an item does not have a widget version of itself. If you need access to the widget of an item, you can use GetWidgetForItem. Remember to check if the widget is valid. Widgets also can’t be transported through a network, so if multiplayer is important to you, your server functions can’t rely on data from widgets."]},{"l":"Finding Items","p":["Finding an item is a very common scenario when you start making your own functions.","The container's TileMap combined with an item's UniqueID is the most reliable way of finding items.","The component includes a function to get an item at item at a specific index of a container called GetItemAtSpecificIndex, then there is a bit more expensive way of finding an item but it’ll go through all containers, GetItemByUniqueID.","The UniqueID is the most reliable method of finding a very specific item, container or item driver, other than a direct reference to the item, container or item driver, but even then a direct reference might get outdated if the player moves the item or modifies it in some way. The UniqueID is only updated for containers and items if they are moved to a new component.","W_Tile also have a reference to the item on top of them, but to reduce memory, tiles have a OwningItem integer which references the top left tile of the item, which holds the ParentItem reference variable. So if you are inside the W_Tile and need to get the item it contains, you would use ParentContainer-> Tiles[ParentTile] -> OwningItem-> GetItemData. Remember to check if ParentTile is -1 first, as that means this tile widget doesn’t have any item inside of it."]},{"l":"Network optimizations","p":["It is recommended, where ever possible, to use the item or container UniqueID instead of the struct in your RPC calls, and then have your server use the UniqueID to figure out which struct to use.","Here you can see 2 sets of RPC calls. One is ReduceItemCount(indicated in red), which is passing the item struct to the server and then to the client. The other is IncreaseItemCount(indicated in blue), which is passing the UniqueID to the server and the server is then using that UniqueID to resolve what item we are trying to modify.","Switching to using the UniqueID method reduced the RPC size from around 75 bytes down to 13.","The only downside is that it is not possible to verify if the client has illegally modified it's data, and it's very difficult to verify that the data inside the item/container are synced. It is up to you whether that is a big enough problem to do this. Some anti-cheat methods already do a very good job at preventing clients from modifying the games data with external tools. If you need to validate the data, you can have the server function still accept the full item/container struct, validate the data, then only pass the UniqueID to the client.","We covered that UniqueID's scale extremely well on another page, but to give you an idea of how well it scales, here's an example","These are two functions using an array with 5 entries of S_UniqueID's (Blue) and an array with 5 entries of S_InventoryItem(Red)"]}],[{"l":"Creating custom widgets"},{"i":"containers-tiles-and-items","l":"Containers, Tiles and Items","p":["These three widgets are the ones you'll most likely end up working with the most. To improve the hierarchy, I've tried to not add any components that aren't necessary. Those that are essential for the widgets to function, I've added Getter functions that request the essential widget. This way you're design hierarchy can be in whatever design you want and still use the parent widgets. But this does mean you need to override those functions and passs the widget through as a variable.","All three are abstract, so you must either use the widgets in the demo folder or make your own children."]},{"l":"Containers","p":["Border is needed for scrolling support and sizing ( GetBorder)","ContainerOverlay holds the item widgets ( GetOverlay)","Grid panel holds the tiles ( GetGridPanel)","(Not mandatory, but is recommended) - Scroll box is needed for scrolling ( GetScrollBox)"]},{"l":"Tiles","p":["Size Box to control the size ( GetSizeBox)"]},{"l":"Inventory Item","p":["size box to control the size ( GetSizeBox)","Image for the item icon ( GetImage)","(Not mandatory, but is recommended) - Loading Throbber for indicating the item is loading ( GetLoadingThrobber) This widget is updated through the I_WidgetUpdates interface. You can see an example of how these updates are used inside WBP_DemoInventoryItem.","The hierarchy inside your custom widget can be structured in whatever way you want, but they must contain the above mentioned widgets inside the hierarchy. Nearly every function inside these widgets are designed to be overriden for maximum customization.","It is advised to read the External widgets page to understand the I_WidgetUpdates interface."]}],[{"l":"Creating new items","p":["Video documentation","Creating new items is very simple. To start off, you'll need to go into the engine and find your content browser, right click and go to Miscellaneous -> Data Asset and a pop up will appear asking you what parent your data asset should derive from. You might have your own children or have removed some of the children that come with the asset, but whatever asset you choose must derive from DA_CoreItem at some point in its hierarchy.","I suggest creating a folder for your item and placing the data asset in there.","To create a blueprint actor for your item, you will have to create an actor who at some point in its hierarchy is a child of BP_SM_ItemPhysical, then set that as your PhysicalActor","The actor will automatically get the blueprint inventory component assigned to it. You will need to go into the component settings and change a few things.","Set InventoryType to \" Pickup\"","Add one index to ContainerSettings and set the ContainerType to \" ThisActor\". This will then hide most of the settings except for the items array.","Your items array should only have one index, which will be your newly created data asset. All settings can be left to their default.","(Optional) If your item has containers associated with it, the data asset should have an array of DefaultContainers. You will want to populate these with your containers and also assign the widget. This variable only exists for weapon and equippable item types. An example can be found in the example project with the gun and backpack item.","To have the asset manager pick up your data asset, it can not be identical to another data asset. (This includes the base file, so if all your variables are set to default, the asset will not get picked up.) Typically you want to immediately give your item a name and a developer image for the InventoryHelper."]},{"i":"creating-new-c-children-of-da_coreitem","l":"Creating new C++ children of DA_CoreItem","p":["You might want to create your own category of items, and since the engine does not allow you to mix C++ and blueprint children of data assets, you are unfortunately forced to create C++ children.","I suggest installing the plugin directly to your project, and then creating new children inside the Items folder, which is found inside the plugins Core folder.","If you are creating a new category, you will also want to find the EItemType enum inside IFP_CoreData.h and create a new entry. Then inside your newly created .cpp file, override the constructor and set the type to be equal to this new category. This is so functions inside of DA_CoreItem can perform the correct casts to retrieve data from its children. You can find examples of this inside of the children of DA_CoreItem that come with the plugin."]}],[{"l":"Drag and drop","p":["A lot of the information PerformDrop function needs to do its calculations and logic should be stored in W_Drag. This is because setting and resetting all that information for all the tiles to optimize memory is simply just so much hassle compared to just putting your stuff in the drag widget, which is always just 1 of so it’s always optimized for memory and no hassle in managing it."]}],[{"l":"External Widgets","p":["Version support: 1.2+","Both the item struct and container struct has an array of ExternalWidgets. There are helper functions for both adding and removing widgets from this array.","What this array allows you to do is have other widgets receive the same update events from the I_WidgetUpdates interface that the item widget and container widget receive. For example, the name getting updated. This can be used for hotbars, quest trackers and more. The example project uses the tooltip widget as an external widget, where it is listening to the override settings getting updated so it can update in real time alongside the item widget.","For your external widgets to receive these updates, you'll want to go to your class settings (1) and implement the I_WidgetUpdates interface (2). You'll then see a IFP category with all the update events. Some of these are limited to just items or containers and some are sent to both.","The I_WidgetUpdates interface is designed to be extended for your needs.","Utilizing external widgets can replace delegate events from the component, but there are still moments where delegates are better, for example a quest tracker keeping track of how much of a specific item data asset you have in your inventory."]}],[{"l":"Modifying critical files","p":["Modifying critical files has its pro's and con's. Removing data is not recommended unless you are ready to fix any problems it might cause. Adding data should not be a problem, but there are some important things you must keep in mind. If your project is single-player only, adding data is a lot safer as there's no network bandwidth you need to manage.","This page covers what is safe, dangerous or optimizations you can perform to critical files this system relies on."]},{"l":"DA_CoreItem","p":["This file is very safe to modify and is intended to be modified. Though it is recommended to make children for each type of item you will have (Weapons, consumables, armor, etc). Though there are several functions you might have to update if you remove any variables or functions. Remember to use soft references as often as possible.","In the base plugin there are a lot of children of this class as examples. All of which are safe to remove if some don't fit your project, though I recommend giving them a quick look-over to explore what differences were made to them."]},{"l":"FS_InventoryItem","p":["This struct will eat up most of your network bandwidth, so adding anything to it can be dangerous. If you are looking to optimize this struct, you \"can\" remove the ContainerIndex and ItemIndex, as those are used to optimize look-ups, though this should be a last resort as a lot of functions will have to be updated."]},{"l":"FS_ContainerSettings","p":["This struct might get a small revamp in the future. The tile map, while it is useful for single player games and drastically speeds up collision tests and look-ups, it might be too expensive for some projects that might have strict network bandwidth. It is not recommended to remove anything unless you are certain you won't need it. Most of the data, other than the tile map, is extremely small."]}],[{"l":"Objects and Drivers","p":["Item drivers should be destroyed after their logic is complete, especially if it’s from a stackable item. The reason being that it’s really hard or almost impossible to keep track of the stack it came from as that stack can be put into other stacks, split or fully used.","You must always keep in mind if the item driver is running logic that’s on a timer, you need to be aware that the item the driver belongs to might become invalid at any point. There is always the chance the item that owns the driver might get destroyed during the timer logic. I also recommend “locking” the player from interacting with the item during this timer or having some sort of failsafe if the player manipulates the item in some way while the timer is still running (For example; a gun playing its pickup animation and the player drops it mid-animation)"]}],[{"l":"Saving and loading","p":["The demo includes an extremely basic save and load system. I will not be implementing anything advanced, because if you ever decide to remove the inventory system from your project, you will have to extract the save and load system from this project. You should have some system which you can bring to all of your projects.","Everything is saved in structs, so it should be compatible with your save system. It’s up to your save and load system to manage this, but if you need an example, the demo project has an example of a simple save and load system.","But let’s be honest, Unreal Engine’s blueprint save system is not very good and lacks too many fundamental features. I recommend a plugin from the marketplace called Saviour.","If you are going to make your own save and load system, I suggest using C++ as the current Blueprint functionality of Unreal's save and load system is really bad. There are a few C++ saving and loading system tutorials on Youtube which cover how to serialize nearly any data you want, all of which should be compatible with this system."]},{"l":"Things to keep in mind","p":["UniqueID's must reset whenever you try to save containers and items. The parent component object reference can not be saved. The component has a function called GetContainersForSaveState which provides you with a copy of the containers, but some data has been modified to be compatible with save files. I recommend looking inside this function to better understand what can not be stored in the save file."]},{"l":"Multiplayer","p":["When a client connects, it's up to your save system to assign them the appropriate container settings."]},{"l":"Equipment","p":["When you load a save, you might want some equipment the player has to become visible. You have two options:","The component has a delegate for when it is started, from which you can assign a Trigger Filter inside of the Equipment Item Driver. These should be instantaneous attachments and no animations should occur at the same time as they can cancel each other before any critical notifies occur.","Your save and load system has the ability to restore actors. From here you must ensure the restored actor gets the owning items UniqueID as a tag, unless you've also implemented a way to save the owning items UniqueID."]}],[{"l":"Tag system","p":["Gameplay tags are extremely powerful and this system attempts to allow itself to expand to various needs using not just gameplay tags, but also a value associated with tags.","There are two systems, a regular gameplay tag and the second being a tag value system. Containers and items can have both. These tags can be updated, removed and added during runtime and are fully replicated.","For example; The system does not by default have a durability system. But with the tag value system, you can add a tag Item.Stat.Durability and give it a value, and voila! You now have a durability system! (Of course you have to implement the background logic that would reduce or increase this value).","The tag system is fairly simple, containers could use them as labels, for example Container.Type.Fridge and now any food items could have a tag value such as Item.Food.Quality which would slowly go down over time, but while in a container with a Container.Type.Fridge tag, it would decay much slower.","There are helper functions for resolving the value of specific tags, finding items or containers with specific tags and more.","Since these tags and values live on the container and item struct, it is very simple to serialize for your save file.","The add, remove and set functions have the option to \"IgnoreNetworkQueue\", if this is check to true, the item will not be added or removed from the network queue. This can be useful for moments where you are fine with server and client data not being in sync for a short moment. If you check this to true, you should NOT rely on that tag for any data validation."]}],[{"l":"Tools","p":["All editor utility widgets are stored inside Plugin folder -> Content -> Core -> Widgets -> EditorUtilityWidgets -> Tools. Any widgets or special components for each editor utility widget is stored in its own folder named after the editor utility widget inside the EditorUtilityWidgets folder. This is done so you can bookmark/favourite the Tools folder and have access to all the tools quickly. You can also find all your editor utility widgets at the top of the editor -> Tools -> Tools, though there is no way to separate the inventory tools from your own editor utility widgets."]},{"l":"IMPORTANT","p":["All widgets, classes or files inside the EditorUtilityWidget folder is NOT designed to be used for a shipping product. If you wish to use anything inside this folder or any widgets used for these tools for your shipping product, you are responsible for ensuring it works properly.","Some tools have a TIPS AND TRICKS comment in their event graph."]}],[{"l":"Inventory Helper","p":["Video documentation","You will very likely be spending a good amount of time using this utility widget, so I suggest bookmarking it or having some way of quickly accessing it while you work.","Working with the raw container struct and the array of items is extremely cumbersome and not very efficient use of time. It also does not provide any sort of feedback of items that might be overlapping or have gone outside the bounds of the container.","This is why I've developed the Inventory Helper. This is a editor utility widget which attempts to mimick the final result you'd see in game and providing a place for you to create your own in-editor tools without going into C++.","It is HIGHLY advised to rarely, if ever, work with the raw container settings array. The only exception is class defaults. Use the inventory helper whenever you can.","Because of how many features this helper has, it becomes a lot to write down, so I've made a video (Not yet released) going over how to use the inventory helper and cover many of its features."]},{"l":"The void system","p":["What might confuse most is the \"Void\" widget and actor. Dragging and dropping an item onto the background will \"pin\" the item exactly where you dropped it. But the item data and its containers must be stored on an actor somewhere in the currently loaded level. The void actor is where that data is stored. This also has the benefit of acting as a proxy for moving an item from one actor to another. You can select one actor, move an item into the void area, then select another actor and move the item into one of its containers."]},{"l":"Limitations","p":["It is NOT recommended to edit the Container Settings through the SelectedComponent widget. The reason being is that the OnPropertyChanged event does not return which index has been modified. Meaning it is not possible to resolve which container or which item was modified, which means that every container widget and item widget must be updated. Only modify the container settings inside this widget if you really have to.","The normal highlight widget is not supported. An alternate method is used instead.","Item splitting is not supported.","Only basic item collision is supported, no combining or stacking.","The Item Void actor is not meant to be interacted with outside the inventory helper. If you wish to modify the Item Void regularily, consider modifying the InventoryHelper and have the tool modify it for you.","Generated item icons do not work. It is suggested to open your game, inspecting the item and saving the generated icon to disk, then setting it inside the data asset."]}],[{"l":"Item Editor","p":["The item editor is a simple, but powerful tool that allows you to select any item the asset manager can detect and directly edit the asset without opening a new window.","This tool is also meant to provide a simple interface for designers to create tools to help with their workflow. There are two tabs, the library and the editor. The library simply is where you can find all your assets and filter them. The second tab is your asset editor. At the bottom you'll find a toolbox. By default there aren't many tools in here, but it is meant for you to expand for your games needs."]},{"l":"Tool box","p":["With the asset comes a icon editor and a shape editor.","The icon editor allows you to edit the inspect and generated item icon settings, and allowing you to see how the item will look like in game with whatever item widget you have selected. You might want to go into WBP_ItemWidgetPreview and setting the default widget class to a class you commonly use.","The shape editor allows you to easily modify the DisabledTiles inside the IO_Shape object, if it has been added to the item.","Tip: You can click and drag to change the state of multiple tiles without having to click over and over again."]}],[{"l":"Item Inspector","p":["WBP_Inspect has a ToggleDebug button on the top bar. Pressing this will expose this tool to the user.","There is a drop down menu allowing you to select whether you want to modify the generated icon settings or the inspection settings.","You can use this for figuring out what rotation and location you want to feed into the generated icon settings. Pressing any of the XYZ rotation or location buttons will rotate or move the mesh by the amount set in the slider. You can also manually put in a value in any of the text boxes. Zoom refers to the camera distance from the item.","You can save your values to the data asset by pressing the Save to Asset button. It is always more efficient for the game thread to NOT generate the item icons via the preview system. It is recommended whenever possible to save the icons and assigning that to the data asset, then disabling Use Generated Item Icon inside the data asset.","The engine does not load assets added to the content browser while a game session is active. For saved item icons to work properly, you must first right click and save the texture, then right click it and press Asset Actions -> Reload","The engine will not properly label the data asset as dirty (an asterisk * indicating that the asset has changes that need to be saved.) after pressing the Save to Asset Button or the Set Icon buttons. You must open the data asset yourself and press save, even though there is no star indicating that there are changes waiting to be saved. If you don't do this, your changes will be lost after closing the editor and it won't prompt you if you want to save the data asset."]}],[{"l":"Versions"},{"l":"Version system","p":["Versions are labeled like so: MajorIteration. MinorIteration. Patches","MajorIteration: New large features, small or large changes to existing files. Updating from one major iteration to another might break some things and downgrading might be difficult. These updates might change fundamental behavior.","MinorIterations: Adjustments to functions, optimizations, new tools or new small or medium sized features. These updates should not break anything, but might still cause initial compile errors.","Patches: Bug fixes, crash fixes, anything that is minor and shouldn't cause any compile errors, these are generally safe to update to."]}],[{"i":"210","l":"2.1.0","p":["Engine support: 5.2 and 5.3","This update focuses on improving developer tools, improving workflow, losening restrictions around item hierarchy and example project updates."]},{"l":"Item actor","p":["The hierarchy around A_ItemPhysicalRepresentation and BP_SM_ItemPhysical has been improved. The inventory component is now added in C++. This does mean BP_SM_ItemPhysical has 2 inventory components for this update. One is labelled deprecated, and you will have to start moving your component settings, such as the InventoryType, ContainerSettings and WidgetClass over to the new one. A button has been added to the actor which will copy over the settings from the deprecated component to the new one. These changes make the blueprint child much more optional and leaves only a few delegates you'll want to setup in any custom children.","Added StartInventoryOnBeginPlay variable as now the inventory component is started inside C++, this will let blueprint designers disable StartComponent on BeginPlay in case they want to customize when it's called.","RootItemID is now replicated."]},{"l":"Inventory component","p":["Added a tag system to the inventory component, though these tags are always replicated and use the default replication system, they do not use the custom replication system the other tag systems use.","Added a quick loot widget, which lets you preview items inside of a component before looting it or opening it, then letting you select and loot specific items without picking up the item or opening it.","Improved how containers are replicated and reduced RPC calls.","ItemMoved delegate has been update to provide both the old and new item data"]},{"l":"Tag system","p":["A new tag value calculation class has been added ( O_TagValueCalculation). These classes can be passed into SetTagValue for both items and containers and it'll allow you to have one place to adjust any values based on some relationship a tag might have with another tag. For example, a durability tag might need to be clamped to a max durability tag. Instead of pre-clamping SetTagValue parameter everywhere inside your code, you now have one spot to perform these adjustments. An example can be found in the example project inside Blueprints -> TagCalculations -> TVC_DurabilityCalculation"]},{"l":"Preview system","p":["Relative location and rotation for the camera has been reworked slightly to resolve some issues. The spring arm location is now applied to the scene capture component instead of the spring arm.","Saving an icon during runtime seems to no longer be supported in 5.2 by Epic, the button is now automatically removed while in-game. You can still save an icon inside the ItemEditor tool."]},{"l":"Editor tools","p":["General UI language has been updated and will continue being updated to feel more like it comes straight out of the box as a Unreal Engine tool, instead of looking like a custom tool with my own personal UI language.","Inspect debug widget has received a major revamp, is now more clear, less clutter, and less buggy.","You can now pan the preview actor around by using the right mouse button.","Item Widget preview has been updated to let you select a tile widget to use as a background and added controls to help with sizing the widget to accurate numbers instead of the scale slider.","The item editor's resizing for the filters and toolbox has been reworked to clear up a collision issue that was happening with sliders.","You can now shift + right click on a asset icon inside the asset library to open the items actor blueprint (If available)."]},{"l":"Equipment System","p":["Tags can be added and removed when driver starts, ends or on specific montage notifies. The example project uses this on the gun to enable/disable firing at specific points."]},{"l":"Bug fixes","p":["InventoryHelper would not scale correctly when the editor scaling was not set to 1","MoveItem could cause crashes in some scenarios where multiple clients were interacting with the same component.","CheckAllRotations was missing UFUNCTION specifier","Sorting items in a list container was not behaving correctly.","Items belonging to a vendor could be dropped without performing any transaction.","TagValueUpdated interface call was not working correctly.","Moving an item into an infinite container could break if the container had to expand to accommodate the item.","GetAllContainersAssociatedWithItem could break if an item contained another item that had a container."]}],[{"i":"201","l":"2.0.1","p":["Engine support: 5.2","Many files have received a large rework/updates and it's not possible to downgrade safely to 1.2. Remember to make backups of your project if you are updating from an older version.","Here is a list of files that have received major changes:","Blueprints:","BP_AC_Inventory","WBP_DemoInventoryItem","WBP_Drag","WBP_Highlight","EUW_InventoryHelper","WBP_ItemWidgetPreview","C++:","AC_Inventory","DA_CoreItem","FL_InventoryFramework"]},{"l":"Highlights","p":["Custom shaped items.","Rotations support for 180 and 270 degrees added.","QA validation system for data assets.","Increased focus on Objects for item data.","Improvements to how item and container widgets are referenced.","Mutlithreaded sorting function"]},{"l":"Items","p":["A validation system has been added to the data asset to help with QA.","Added AssetTags and AssetTagValues to the data asset. These are similar to the default tags, except they are NOT added to the item struct and can not be modified, removed or added during runtime.","Added GetNearbyItems function.","Attachment type This change has a host of benefits. It is one less reason to install locally, easier to expand, manage and more. This also has the benefit of allowing all of these to be easily overridable during runtime. This also means CompatibilitySettings and CheckCompatibility has been updated. CheckCompatibility will no longer check the deprecated enums to reduce confusion for new people.","Equipment slot","Equipment type","Helper functions for rotating and evaluating an items shape have been added.","Item rarity","Items can now be rotated 0, 90, 180 and 270 degrees.","Items now support custom shapes. This can be enabled by adding the \"Custom Shape\" object to an items data asset.","Price and Default Accepted Currencies moved to IO_Pricing","The first multithreaded sorting function has been added. For now I'm starting with just sorting by name to find out if the current approach works. If the current approach works, I'll start working on more sorting functions and hopefully make a tutorial on how to make your own custom sorting function.","The following enums have been deprecated and replaced with the items tags:","The following variables have been deprecated and replaced with objects:","The function CheckBothRotationsForSpace has been deprecated because the name does not make sense anymore. Has been replaced with CheckAllRotationsForSpace","This is achieved through a validation class (so you can write your validation at a blueprint level) and a interface function from I_Validation. The plugin comes with a basic example.","Weapon type","When an item is equipped and using a blueprint actor as it's physical representation, the root items UniqueID is now passed to the actor and stored inside RootItemID, allowing the spawned actor to access it's true item data."]},{"l":"Tag system","p":["Various functions have been added to validate if a tag and tag values can or can not be added, removed or set for both items and containers.","The Tag value struct now has a custom editor slate widget to make it easier to work with and take up less space.","Note: As of 5.2, there's a bug with some custom structs and editor utility widgets not displaying the custom struct correctly. To get around this, I've made it so it displays the default struct widget while inside a editor utility widget.","TileTags have been added for containers to replace HiddenSlots and LockedSlots, which are now deprecated. This is a prototype, it currently can not be modified during runtime for multiplayer and there are no events for when a tag is removed or added."]},{"l":"Widgets","p":["Both the drag and highlight widget have been updated to behave more intuitively with custom shaped items. This also means both have been reworked quite heavily. For non-grid containers, the behavior should remain the same as before.","The drag and drop operation no longer has a visual and WBP_Drag is now added to the screen (You might have to set the ZOrder). This is to resolve a interpoloation issue you could not control inside the drag and drop operation drag visual and improve the consistency of WBP_Drag.","Attachment widgets no longer need a reference to the parent items widget.","Attachment widgets now remove themselves correctly from the parent item when it is destroyed.","Both the item struct and container struct now reference the item widget and container widget respectively.","AC_Inventory-> ContainerWidgets has been deprecated as the container struct now references the container widgets. Added GetAllContainerWidgets and RemoveAllContainerWidgets to replace the array."]},{"l":"Objects and drivers","p":["Objects have had their hierarchy changed. There is now a \"pure\" ( O_PureItemObject) item object below the regular item object, which is now meant for data only objects. This is to optimize memory footprint as the framework becomes more focused on objects and for projects that are heavily utilizing the object system.","ConstructionMethod is getting deprecated. You should reparent your data-only objects to O_PureItemObject.","Objects can now prevent multiple copies of themselves inside an item assets ObjectsAndDrivers array. By default this is set to false, to change it you must override the AllowMultipleCopiesInDataAsset function.","Objects now get notified when they are added to the item assets array with AddedToItemAsset. Allowing for more complicated default variables.","Added object for pricing ( IO_Pricing)."]},{"l":"Tools","p":["A shape editor has been added to the ItemEditor's toolbox.","A conversion tool has been added to help convert the deprecated enums listed above into gameplay tags and move some deprecated variables into their new objects. This tool will be removed in 2.1 and is only meant to help those upgrading from 1.2 to 2.0.","Container handle bar context menu has been removed from the inventory helper."]},{"l":"Bug fixes","p":["When removing an item as listen server, it would attempt to remove the item twice.","Attachment widgets were not being removed correctly in some scenarios.","GetItemDriver was not returning client-only objects for single player sessions.","Skeletal mesh equipment animations could end up in an infinite loop if they contained a MontageNotify with the same name as their WaitForNotify.","Equipment system for clients would try to play an animation on skeletal meshes with WaitForNotify and then create it, causing the animation to not play as the mesh had not been replicated yet.","Updating the unequip location for static and skeletal meshes was not functioning correctly.","CheckCompatibility would not take the items default tags and tag values into consideration while in the editor.","Increase and Decrease item count could crash if invalid item data was passed in.","TryAddNewItem could cause issues with CheckCompatibility"]}],[{"i":"120","l":"1.2.0","p":["Engine support: 5.2"]},{"i":"important-for-those-updating","l":"Important for those updating:","p":["Because both the container struct and item struct were modified in this update, it means that a lot of blueprints were updated and might override any chances you might have made. Remember to backup your version before installing."]},{"l":"Component","p":["FindFirstAvailableContainerAndTile and FindFirstAvailableTile have been replaced with GetFirstAvailableContainerAndTile and GetFirstAvailableTile. These functions can now also be overriden at a blueprint level to allow designers to implement their own rules of how the system finds available containers and tiles.","CheckForSpace and CheckBothRotationsForSpace has been updated to return an array of items that were in the way instead of just the first item.","Added function for checking if items can be swapped and another function for swapping 2 item locations.","Added UpdateItemsOverrideSettings so override settings can be updated in a live multiplayer session. Another function called CanActorChangeItemOverrideSettings has been added and it will ask the server if an actor is allowed to modify an items override settings. By default, this is set to always return true. You can override this function at a blueprint level."]},{"l":"Items","p":["Default item tags have been implemented. These are defined in the item data asset, whenever a component is started and an item does not have any of the tags from the data asset, they will automatically be applied.","ContainerName has been labelled as deprecated and will be replaced with ContainerIdentifier tag, making it easier for renaming a container and reduces human error when binding containers with their widget representation.","During 1.2 both the ContainerName will continue to work for most functions, as most have been updated to use ContainerIdentifier instead, but ContainerName will be fully removed in the next update. It's recommended to update your containers immediately.","The physical actor for an item no longer requires any containers to be setup inside the blueprint. When the component is started, it'll automatically add the default containers from the data asset."]},{"l":"Item drivers","p":["Item drivers now have the option to \"follow\" the item they were created by. This means that if a driver is created for an item and the item is moved to a new actor, that driver is moved as well to the new actor. The driver is not destroyed and reconstructed, it will retain all information and continue running any timer logic.","Drivers are now referenced by the item struct, giving easy access to access an items item driver."]},{"l":"Widgets","p":["The update functions inside of W_InventoryItem have been labelled as deprecated.","New I_WidgetUpdates interface added, contains all the update functions that were deprecated in W_InventoryItem","During 1.2 both the deprecated functions and the interface events will be called, but the update functions inside of W_InventoryItem will be fully removed in the next update.","Item struct and container struct now has an array of \" External Widgets\", making it easier to manage hotbars, quest trackers and any other widget that is listening to any item updates without listening to a bunch of delegates. Documentation can be found here","External widgets get all the same Update functions that the item widget and container widget does from the I_WidgetUpdates interface.","More update functions have been added for tags, tag values and equip/unequip events.","Add, Remove and Get External Widgets helper functions for both items and containers have been added."]},{"l":"Example Project","p":["Added two quick slot example, one for global tracking where a specific item asset is tracked across the entire inventory, and another for a specific slot.","In the context menu, the Equip and Unequip buttons now actually... You know... Equips and unequips the item...","Example project has been updated to no longer use any of the deprecated features.","Gameplay tags have been moved to a data table.","The tooltip widget has been updated to use the external widget system to provide a simple example of the new external widget system.","Objects now have a better display name."]},{"l":"Bug fixes","p":["When splitting an item, the newly created item widget would get created in the incorrect location.","When trying to move an item on the same slot but with a new rotation, it would not update the rotation.","Generated item icon were being stretched in certain scenarios.","Item count was getting reset to default if it was dropped.","Random min/max count could be called multiple times.","The item and container tag delegates are no longer getting spammed.","GetItemDimensions could sometimes return wrong values","Set/Remove tag value and IncreaseItemCount wasn't using the new replication system."]}],[{"i":"111","l":"1.1.1","p":["Engine support: 5.1 and 5.2"]},{"l":"Improvements","p":["Preview actor now destroys its own collider actor when itself is destroyed.","Refreshing the preview actor is now faster.","General code cleanup and unused variables have been removed.","Items can now be labelled as \"new\". This label can be removed at any point. This can help players find out what is new in their inventory and they haven't interacted with yet.","Items that do not have their containers added to the ContainerSettings array will now retrieve their default containers from the data asset and add those to the component when it is started.","A tag system has been added, allowing you to add tags to items and containers, and also associated values to certain tags."]},{"l":"Tools","p":["New tool as been added, the ItemEditor.","Added function library for editor tools.","Common data base widget added so it is easy and fast to add your item data base to any editor tool.","It is now possible to generate item icons while in the editor.","Improved multiple widgets behavior and accessability while in the editor.","Added a tool for previewing how an item widget will appear in-game while in the editor."]},{"l":"Bug fixes","p":["Refreshing the preview actor no longer breaks on shipping build for some actors.","Preview actor no longer 1-frame snaps or resets visual effects when refreshed. It now resolves what components have and have not been duplicated and only updates those.","Fixed an issue where item rarity colors were not working while in the editor."]},{"i":"111-1","l":"1.1.1","p":["Note: This is 5.2 only. Apparently Epic decided after manually reviewing the 5.1 version within 7 minutes said \"There were no notable differences\" so they just won't accept it...","Autonomous Proxies on listen no longer is breaking replication.","When an item was dropped, the containers belonging to any children item were not being removed properly."]}],[{"i":"100","l":"1.0.0","p":["Engine support: 5.1","Official release"]}],[{"i":"faq","l":"F.A.Q"},{"i":"q-can-the-system-be-used-for-a-more-traditional-inventory-system-where-all-items-are-1x1","l":"Q: Can the system be used for a more traditional inventory system where all items are 1x1?","p":["A: Of course! Containers have styles, and the List style already converts all items into 1x1."]},{"i":"q-is-there-a-crafting-system-implemented","l":"Q: Is there a crafting system implemented?","p":["A: Right now, no. I am currently experimenting with a crafting system that might be abstract enough to fit into the plugin. It'll most likely get added around 2.3. At the end of the day, crafting systems just require item data and some form of a “recipe”. It should not be difficult to create your crafting system with the item data system this asset uses and the functions the inventory component has. Some people already have added a crafting system, so it is completely possible."]},{"i":"q-will-statsattributes-or-ability-systems-of-any-kind-be-added","l":"Q: Will stats/attributes or ability systems of any kind be added?","p":["A: No. I believe most people should be using the Gameplay Ability System framework as it is becoming the industry standard or something similar (I personally suggest GAS Companion from the marketplace). A lot of people also already have a stat/attribute or ability system in place and I do not want to step on their toes. The tag system does allow you to create basic stats and attributes for items, but I generally recommend people use GAS or a more fleshed out system designed around that."]},{"i":"q-will-i-be-adding-any-art-meshes-or-animations-to-the-asset","l":"Q: Will I be adding any art, meshes or animations to the asset?","p":["A: No, with the exception of some basic things like the Tile Icon and some other things, just enough so you don’t get any compile errors and can interact with the system before you implement your art."]},{"i":"q-does-the-plugin-feature-an-interaction-system","l":"Q: Does the plugin feature an interaction system?","p":["A: This plugin does not provide a fleshed-out interaction system for you, but an interface system is integrated in the demo's as that's the foundation of every interaction system I've seen. This is done so your project does not build a dependancy on my interaction system if you ever decide this plugin does not fit your project. The interaction system is designed to be replaced, as most people already have an interaction system already in place."]},{"i":"q-will-i-be-adding-x-featuresystem","l":"Q: Will I be adding X feature/system?","p":["A: Only if it’s a highly requested feature, only then will I either implement it into the base asset itself or make a youtube tutorial on how to implement it yourself. You can track what is being worked on and what will be worked on in the future by going to the Trello link at the top of the page."]}],[{"l":"Bugs","p":["This list is only relevant to the latest version of the plugin, old version of the plugin will slowly lose bug-tracking. If you are on a old version of the plugin and have found a bug, you can always ask on the discord for help."]},{"l":"Known Bugs","p":["The \"Reset to Default Property Value\" button for container settings is not resetting values to their proper defaults and it's always showing for all values, even if the value is set to its default. I am unsure what is causing this.","The drag widgets sizing is much larger than it is supposed to be for a couple of frames. There is currently a 0.05 delay inside WBP_Drag to resolve this. This is a band-aid fix, I'll try to resolve this fully in the future.","While inside a editor utility widget, the gameplay tags slate widget is not updating properly. The DetailsView widget is riddled with a few bugs as of at least 5.2 when it comes to custom slate struct widgets. The best you can do right now is open the gameplay tag to see what values are inside of it and adding/removing something to update it, then it'll show the values inside the tag correctly.","In 5.2, saving an icon has a high chance of crashing the editor. This is an engine bug, it seems to happen at random. If anyone knows a fix, let me know.","The UE \"Clamp (Float)\" node's behavior has changed between 5.2 and 5.3, causing highlight widget when dragging an item to be able to go outside the boundaries of the container. I'm not going to try and fix this, as it's not a critical issue, just a visual one, and it seems like this is a bug on Epic's side. If it's not fixed in 5.3.1/5.4, then I'll fix it."]},{"l":"Common Problems","p":["These aren't bugs, but problems that can be misinterpreted as bugs.","The inspector debugger changes are being set but not being saved after closing the editor. This is because the engine seemingly refuses to label assets as dirty while a gameplay session is active and doesn't label them as dirty after closing the gameplay session. An asset that is dirty will have an asterisk (*) indicating that you have changes that need to be saved, but since it refuses to label it as dirty, it means that you have to manually open the asset and pressing save, even though there is no star indicating that you have changes that need to be saved. This may be a engine bug or is intended, but it seems that there's nothing I can do about this.","The WBP_Highlight widget and WBP_InventoryItem widget padding doesn't take into account any scaling their parent widgets have to do (like borders). So if you are getting issues with items being dropped in a different tile or an item not lining up properly, there is most likely an issue with your UMG hierarchy/scaling. You might have this problem with scroll bars most of the time. An easy fix for that is to go into the ScrollBox, go into Scrollbar Padding, let's say the scroll bar is on the right side, go into the right side padding and minus the thickness of the bar.","BP_PreviewActor's automated camera distance is determined by all components which have collision enabled. This means if you have collision hitboxes or something similar on your actors, the camera will try to adjust to fit that in the camera view. Remember to use the tag “ DONOTPREVIEW” on those collision components if the BP_PreviewActor is copying them.","Your item is not showing up in the asset manager or your getting a \"Ignoring PrimaryAssetType Items - Conflicts with SOMECLASSNAME - Asset: ITEMNAMEHERE\" in your message log. This happens when there are two identical data assets. This will most likely happen when you have two completely blank data assets and/or haven't filled in any of the data yet.","The highlight widget is going outside the boundaries of the container or is getting clipped. This happens if the sizing of the widget does not match the container dimensions. This is most common if the container is slotted into a canvas panel. If that is the case, you can check \"Size To Content\". For other widgets, you will have to manage the sizing of the container and in some cases, it's handled automatically.","After adding or changing default values inside FS_InventoryItem, the InventoryHelper will falsely report a value is no longer set to default and will reset it to the wrong value when pressing the reset button. This is happening because the struct inside the InventoryHelper did not get updated. You must go into EUW_InventoryHelper and find SelectedItem and update its default settings. The same might happen to the context menu, so you must go to WBP_ContextMenu_EditorOnly and find Item and update its default settings."]}]]